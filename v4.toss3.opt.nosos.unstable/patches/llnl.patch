diff --git a/configure.ac b/configure.ac
index 85c3f489..85263ad5 100644
--- a/configure.ac
+++ b/configure.ac
@@ -303,6 +303,8 @@ AM_CONDITIONAL([ENABLE_GRPTEST_LDMS_TEST], [test "x$ENABLE_LDMS_TEST_FALSE" = "x
 dnl options for contributed samplers
 OPTION_DEFAULT_DISABLE([ipmireader], [ENABLE_IPMIREADER])
 OPTION_DEFAULT_DISABLE([tutorial-sampler],[ENABLE_TUTORIAL_SAMPLER])
+OPTION_DEFAULT_DISABLE([ldms-plugins-llnl],[ENABLE_LDMS_PLUGINS_LLNL])
+CONTRIB_LLNL
 
 dnl check for libcurl if influx is configured
 OPTION_DEFAULT_DISABLE([influx], [ENABLE_INFLUX])
@@ -760,6 +762,9 @@ ldms/src/sampler/examples/test_sampler/Makefile
 ldms/src/sampler/ibm_occ/Makefile
 ldms/src/sampler/syspapi/Makefile
 ldms/src/contrib/sampler/Makefile
+ldms/src/contrib/sampler/ldms-plugins-llnl/Makefile
+ldms/src/contrib/sampler/ldms-plugins-llnl/src/Makefile
+ldms/src/contrib/sampler/ldms-plugins-llnl/man/Makefile
 ldms/src/contrib/sampler/ipmireader/Makefile
 ldms/src/contrib/sampler/tutorial/Makefile
 ldms/src/third-plugins/Makefile
diff --git a/ldms/src/contrib/sampler/Makefile.am b/ldms/src/contrib/sampler/Makefile.am
index 17f1c845..3d66a732 100644
--- a/ldms/src/contrib/sampler/Makefile.am
+++ b/ldms/src/contrib/sampler/Makefile.am
@@ -14,6 +14,11 @@ if ENABLE_TUTORIAL_SAMPLER
 endif
 SUBDIRS += $(MAYBE_TUTORIAL_SAMPLER)
 
+if ENABLE_LDMS_PLUGINS_LLNL
+    MAYBE_LDMS_PLUGINS_LLNL = ldms-plugins-llnl
+endif
+SUBDIRS += $(MAYBE_LDMS_PLUGINS_LLNL)
+
 
 
 
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/COPYRIGHT b/ldms/src/contrib/sampler/ldms-plugins-llnl/COPYRIGHT
new file mode 100644
index 00000000..78a42857
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/COPYRIGHT
@@ -0,0 +1,22 @@
+Intellectual Property Notice
+------------------------------
+
+ldms-plugins-llnl is licensed under the terms of both the GNU General Public
+License, Version 2 (LICENSE-GPL) and the BSD 3-Clause License (LICENSE-BSD).
+Users may choose either license, at their option.
+
+Copyrights and patents in the ldms-plugins-llnl project are retained by
+contributors.  No copyright assignment is required to contribute to
+ldms-plugins-llnl.
+
+SPDX usage
+------------
+
+Individual files contain SPDX tags instead of the full license text.
+This enables machine processing of license information based on the SPDX
+License Identifiers that are available here: https://spdx.org/licenses/
+
+Files that are dual-licensed as GPLv2 OR BSD contain the following
+text in the license header:
+
+    SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/LICENSE-BSD b/ldms/src/contrib/sampler/ldms-plugins-llnl/LICENSE-BSD
new file mode 100644
index 00000000..89442d9a
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/LICENSE-BSD
@@ -0,0 +1,29 @@
+BSD 3-Clause License
+
+Copyright (c) 2018, Lawrence Livermore National Security, LLC
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met:
+
+* Redistributions of source code must retain the above copyright notice, this
+  list of conditions and the following disclaimer.
+
+* Redistributions in binary form must reproduce the above copyright notice,
+  this list of conditions and the following disclaimer in the documentation
+  and/or other materials provided with the distribution.
+
+* Neither the name of the copyright holder nor the names of its
+  contributors may be used to endorse or promote products derived from
+  this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/LICENSE-GPL b/ldms/src/contrib/sampler/ldms-plugins-llnl/LICENSE-GPL
new file mode 100644
index 00000000..9bd56be5
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/LICENSE-GPL
@@ -0,0 +1,339 @@
+GNU GENERAL PUBLIC LICENSE
+   Version 2, June 1991
+
+Copyright (C) 1989, 1991 Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+Everyone is permitted to copy and distribute verbatim copies
+of this license document, but changing it is not allowed.
+
+        Preamble
+
+The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Lesser General Public License instead.)  You can apply it to
+your programs, too.
+
+When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+The precise terms and conditions for copying, distribution and
+modification follow.
+
+GNU GENERAL PUBLIC LICENSE
+TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+a) You must cause the modified files to carry prominent notices
+stating that you changed the files and the date of any change.
+
+b) You must cause any work that you distribute or publish, that in
+whole or in part contains or is derived from the Program or any
+part thereof, to be licensed as a whole at no charge to all third
+parties under the terms of this License.
+
+c) If the modified program normally reads commands interactively
+when run, you must cause it, when started running for such
+interactive use in the most ordinary way, to print or display an
+announcement including an appropriate copyright notice and a
+notice that there is no warranty (or else, saying that you provide
+a warranty) and that users may redistribute the program under
+these conditions, and telling the user how to view a copy of this
+License.  (Exception: if the Program itself is interactive but
+does not normally print such an announcement, your work based on
+the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+a) Accompany it with the complete corresponding machine-readable
+source code, which must be distributed under the terms of Sections
+1 and 2 above on a medium customarily used for software interchange; or,
+
+b) Accompany it with a written offer, valid for at least three
+years, to give any third party, for a charge no more than your
+cost of physically performing source distribution, a complete
+machine-readable copy of the corresponding source code, to be
+distributed under the terms of Sections 1 and 2 above on a medium
+customarily used for software interchange; or,
+
+c) Accompany it with the information you received as to the offer
+to distribute corresponding source code.  (This alternative is
+allowed only for noncommercial distribution and only if you
+received the program in object code or executable form with such
+an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+        NO WARRANTY
+
+11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+ END OF TERMS AND CONDITIONS
+
+How to Apply These Terms to Your New Programs
+
+If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+<one line to give the program's name and a brief idea of what it does.>
+Copyright (C) <year>  <name of author>
+
+This program is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2 of the License, or
+(at your option) any later version.
+
+This program is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+GNU General Public License for more details.
+
+You should have received a copy of the GNU General Public License along
+with this program; if not, write to the Free Software Foundation, Inc.,
+51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+Gnomovision version 69, Copyright (C) year name of author
+Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+This is free software, and you are welcome to redistribute it
+under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+`Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+<signature of Ty Coon>, 1 April 1989
+Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/Makefile.am b/ldms/src/contrib/sampler/ldms-plugins-llnl/Makefile.am
new file mode 100644
index 00000000..e585f747
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/Makefile.am
@@ -0,0 +1,8 @@
+EXTRA_DIST = COPYRIGHT LICENSE-BSD LICENSE-GPL NOTICE README.md
+
+docdir=$(datadir)/doc/ldms-plugins-llnl
+
+dist_doc_DATA = \
+COPYRIGHT LICENSE-BSD LICENSE-GPL NOTICE README.md VERSION
+
+SUBDIRS = src man
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/NOTICE b/ldms/src/contrib/sampler/ldms-plugins-llnl/NOTICE
new file mode 100644
index 00000000..3737d5a8
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/NOTICE
@@ -0,0 +1,21 @@
+This work was produced under the auspices of the U.S. Department of
+Energy by Lawrence Livermore National Laboratory under Contract
+DE-AC52-07NA27344.
+
+This work was prepared as an account of work sponsored by an agency of
+the United States Government. Neither the United States Government nor
+Lawrence Livermore National Security, LLC, nor any of their employees
+makes any warranty, expressed or implied, or assumes any legal liability
+or responsibility for the accuracy, completeness, or usefulness of any
+information, apparatus, product, or process disclosed, or represents that
+its use would not infringe privately owned rights.
+
+Reference herein to any specific commercial product, process, or service
+by trade name, trademark, manufacturer, or otherwise does not necessarily
+constitute or imply its endorsement, recommendation, or favoring by the
+United States Government or Lawrence Livermore National Security, LLC.
+
+The views and opinions of authors expressed herein do not necessarily
+state or reflect those of the United States Government or Lawrence
+Livermore National Security, LLC, and shall not be used for advertising
+or product endorsement purposes.
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/README.md b/ldms/src/contrib/sampler/ldms-plugins-llnl/README.md
new file mode 100644
index 00000000..61ee557d
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/README.md
@@ -0,0 +1,24 @@
+The plugins in ldms-plugins-llnl compile against LDMS v3.  They will likely
+also compile against LDLMS v4 when that is released.
+
+The llnl_lustre_client plugin is fully functional against LDMS v3.  The llnl_lustre_mdt
+and llnl_lustre_ost plugins will require an LDMS v4 that fixes ldms_set_delete() (Likely
+OVIS 4.3.0 or later).
+
+License
+----------------
+
+ldms-plugins-llnl is distributed under the terms of both the GNU General Public
+License (Version 2) and the BSD 3-Clause License. Users may choose either license,
+at their option.
+
+All new contributions must be made under both the GPL and BSD licenses.
+
+See [LICENSE-GPL](https://github.com/llnl/ldms-plugins-llnl/blob/master/LICENSE-GPL),
+[LICENSE-BSD](https://github.com/llnl/ldms-plugins-llnl/blob/master/LICENSE-BSD),
+[COPYRIGHT](https://github.com/llnl/ldms-plugins-llnl/blob/master/COPYRIGHT), and
+[NOTICE](https://github.com/llnl/ldms-plugins-llnl/blob/master/NOTICE) for details.
+
+SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+
+LLNL-CODE-774582
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/VERSION b/ldms/src/contrib/sampler/ldms-plugins-llnl/VERSION
new file mode 100644
index 00000000..1729ba42
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/VERSION
@@ -0,0 +1 @@
+1.5 https://github.com/LLNL/ldms-plugins-llnl/tree/1.5 78356097638ef2ed19eadb068cff88580b2a362b
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Makefile.am b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Makefile.am
new file mode 100644
index 00000000..5299d3a9
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Makefile.am
@@ -0,0 +1,7 @@
+dist_man7_MANS = Plugin_llnl_lustre_ost.man
+dist_man7_MANS += Plugin_llnl_lustre_mdt.man
+dist_man7_MANS += Plugin_llnl_lustre_client.man
+if HAVE_DCGM
+dist_man7_MANS += Plugin_llnl_dcgm.man
+endif
+EXTRA_DIST=Plugin_llnl_dcgm.man
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_dcgm.man b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_dcgm.man
new file mode 100644
index 00000000..1c7aacb8
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_dcgm.man
@@ -0,0 +1,59 @@
+.TH man 7 "1 May 2019" "LDMS Plugin" "LLNL Plugin for LDMS"
+
+.SH NAME
+Plugin_llnl_dcgm - man page for the LDMS llnl_dcgm plugin
+
+.SH SYNOPSIS
+Within ldmsd_controller or a configuration file:
+.br
+config name=llnl_dcgm
+
+.SH DESCRIPTION
+With LDMS (Lightweight Distributed Metric Service), plugins for the ldmsd (ldms daemon) are configured via ldmsd_controller
+or a configuration file. The llnl_dcgm plugin provide a metric set for each DCGM-compatible Nvidia GPU on the system.
+The schema is named "llnl_dcgm" by default.
+
+.SH CONFIGURATION ATTRIBUTE SYNTAX
+
+.TP
+.BR config
+name=<plugin_name> interval=<interval(us)> [fields=<fields>] [schema=<schema_name>]
+.br
+configuration line
+.RS
+.TP
+name=<plugin_name>
+.br
+This MUST be llnl_dcgm.
+.TP
+interval=<interval(us)>
+.br
+The sampling interval.  This MUST be set to the same value that is
+set on the "start" line, otherwise behavior is undetermined.
+.TP
+fields=<fields>
+.br
+<fields> is a comma-separated list of integers representing DCGM field
+numebers that the plugin should watch.  By default the plugin will
+watch fields 150,155.
+.TP
+schema=<schema_name>
+.br
+The schema name defaults to "llnl_dcgm", but it can be renamed at the
+user's choice.
+.RE
+
+.SH BUGS
+No known bugs.
+
+.SH EXAMPLES
+.PP
+Within ldmsd_controller or a configuration file:
+.nf
+load name=llnl_dcgm
+config name=llnl_dcgm interval=1000000 fields=150,155,1001,1002,1003 schema=dcgmfav5
+start name=llnl_dcgm interval=1000000
+.fi
+
+.SH SEE ALSO
+ldmsd(8), ldms_quickstart(7), ldmsd_controller(8), ldms_sampler_base(7)
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_client.man b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_client.man
new file mode 100644
index 00000000..2a63a1fd
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_client.man
@@ -0,0 +1,58 @@
+.TH man 7 "1 May 2019" "LDMS Plugin" "LLNL Plugin for LDMS"
+
+.SH NAME
+Plugin_llnl_lustre_client - man page for the LDMS llnl_lustre_client plugin
+
+.SH SYNOPSIS
+Within ldmsd_controller or a configuration file:
+.br
+config name=llnl_lustre_client
+
+.SH DESCRIPTION
+With LDMS (Lightweight Distributed Metric Service), plugins for the ldmsd (ldms daemon) are configured via ldmsd_controller
+or a configuration file. The llnl_lustre_client plugin provide a metric set for each of the lustre client
+mounts found on a node.  The schema is named "llnl_lustre_client".  The data for the metric sets is
+generally found in /proc/fs/lustre/llite/*/stats.
+
+This plugin currently employs zero configuration.  The producer name is set to the hostname, and the metric set instance names are
+derived from the llite instance name.  Any user-supplied configuration values will be ignored.  Future versions may add
+configuration options.
+
+This plugin should work with at least Lustre versions 2.8, 2.10, and 2.12.
+
+NOTE: This plugin is only expected to be fully function in an ovis v4 release
+in which the ldms_set_delete() function is fixed.  (Which specific v4 release
+will have the fix is unknown at the time of writing.)  It will _mostly_ work
+with ovis v3, but an llite name such as "lquake-ffff000a000b7800" can never
+be reused once it disappears from /proc.  This is not likely to be a problem
+most of the time, but if it ever happens an ldmsd daemon restart will be
+required to use the name again.
+
+.SH CONFIGURATION ATTRIBUTE SYNTAX
+
+.TP
+.BR config
+name=<plugin_name>
+.br
+configuration line
+.RS
+.TP
+name=<plugin_name>
+.br
+This MUST be llnl_lustre_client.
+.RE
+
+.SH BUGS
+No known bugs.
+
+.SH EXAMPLES
+.PP
+Within ldmsd_controller or a configuration file:
+.nf
+load name=llnl_lustre_client
+config name=llnl_lustre_client
+start name=llnl_lustre_client interval=1000000
+.fi
+
+.SH SEE ALSO
+ldmsd(8), ldms_quickstart(7), ldmsd_controller(8), ldms_sampler_base(7)
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_mdt.man b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_mdt.man
new file mode 100644
index 00000000..3ec55f57
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_mdt.man
@@ -0,0 +1,61 @@
+.TH man 7 "1 May 2019" "LDMS Plugin" "LLNL Plugin for LDMS"
+
+.SH NAME
+Plugin_llnl_lustre_mdt - man page for the LDMS llnl_lustre_mdt plugin
+
+.SH SYNOPSIS
+Within ldmsd_controller or a configuration file:
+.br
+config name=llnl_lustre_mdt
+
+.SH DESCRIPTION
+With LDMS (Lightweight Distributed Metric Service), plugins for the ldmsd (ldms daemon) are configured via ldmsd_controller
+or a configuration file.
+
+The llnl_lustre_mdt plugin provide metric sets for two different schemas: llnl_lustre_mdt and llnl_lustre_mdt_job_stats.
+
+The metric sets using schema llnl_lustre_mdt will have a producer name set to the hostname,
+and the instance name set to the mdt name.  The data for these metrics sets come from a combination
+of the data in /proc/fs/lustre/mdt/*/stats and a few other single-value files in /proc/fs/lustre/mdt/*/.
+
+The metric sets using schema llnl_lustre_mdt_job_stats will have a producer name set to the hostname,  and the
+instance name will be set to a combination of the mdt name and the job_id string.  The data for these metrics sets
+come from /proc/fs/lustre/mdt/*/job_stats.
+
+This plugin currently employs zero configuration. Any user-supplied configuration values will be ignored.  Future versions may add
+configuration options.
+
+This plugin should work with at least Lustre versions 2.8, 2.10, and 2.12.
+
+NOTE: This plugin is only expected to be fully function in an ovis v4 release
+in which the ldms_set_delete() function is fixed.  (Which specific v4 release
+will have the fix is unknown at the time of writing.)
+
+.SH CONFIGURATION ATTRIBUTE SYNTAX
+
+.TP
+.BR config
+name=<plugin_name>
+.br
+configuration line
+.RS
+.TP
+name=<plugin_name>
+.br
+This MUST be llnl_lustre_mdt.
+.RE
+
+.SH BUGS
+No known bugs.
+
+.SH EXAMPLES
+.PP
+Within ldmsd_controller or a configuration file:
+.nf
+load name=llnl_lustre_mdt
+config name=llnl_lustre_mdt
+start name=llnl_lustre_mdt interval=1000000
+.fi
+
+.SH SEE ALSO
+ldmsd(8), ldms_quickstart(7), ldmsd_controller(8), ldms_sampler_base(7)
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_ost.man b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_ost.man
new file mode 100644
index 00000000..4855768e
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/man/Plugin_llnl_lustre_ost.man
@@ -0,0 +1,61 @@
+.TH man 7 "1 May 2019" "LDMS Plugin" "LLNL Plugin for LDMS"
+
+.SH NAME
+Plugin_llnl_lustre_ost - man page for the LDMS llnl_lustre_ost plugin
+
+.SH SYNOPSIS
+Within ldmsd_controller or a configuration file:
+.br
+config name=llnl_lustre_ost
+
+.SH DESCRIPTION
+With LDMS (Lightweight Distributed Metric Service), plugins for the ldmsd (ldms daemon) are configured via ldmsd_controller
+or a configuration file.
+
+The llnl_lustre_ost plugin provide metric sets for two different schemas: llnl_lustre_ost and llnl_lustre_ost_job_stats.
+
+The metric sets using schema llnl_lustre_ost will have a producer name set to the hostname,
+and the instance name set to the ost name.  The data for these metrics sets come from a combination
+of the data in /proc/fs/lustre/ost/*/stats and a few other single-value files in /proc/fs/lustre/ost/*/.
+
+The metric sets using schema llnl_lustre_ost_job_stats will have a producer name set to the hostname,  and the
+instance name will be set to a combination of the ost name and the job_id string.  The data for these metrics sets
+come from /proc/fs/lustre/ost/*/job_stats.
+
+This plugin currently employs zero configuration. Any user-supplied configuration values will be ignored.  Future versions may add
+configuration options.
+
+This plugin should work with at least Lustre versions 2.8, 2.10, and 2.12.
+
+NOTE: This plugin is only expected to be fully function in an ovis v4 release
+in which the ldms_set_delete() function is fixed.  (Which specific v4 release
+will have the fix is unknown at the time of writing.)
+
+.SH CONFIGURATION ATTRIBUTE SYNTAX
+
+.TP
+.BR config
+name=<plugin_name>
+.br
+configuration line
+.RS
+.TP
+name=<plugin_name>
+.br
+This MUST be llnl_lustre_ost.
+.RE
+
+.SH BUGS
+No known bugs.
+
+.SH EXAMPLES
+.PP
+Within ldmsd_controller or a configuration file:
+.nf
+load name=llnl_lustre_ost
+config name=llnl_lustre_ost
+start name=llnl_lustre_ost interval=1000000
+.fi
+
+.SH SEE ALSO
+ldmsd(8), ldms_quickstart(7), ldmsd_controller(8), ldms_sampler_base(7)
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/Makefile.am b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/Makefile.am
new file mode 100644
index 00000000..c02315d0
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/Makefile.am
@@ -0,0 +1,51 @@
+ACLOCAL_AMFLAGS = -I m4
+
+COMMON_LIBADD = -lldms -lcoll
+COMMON_LDFLAGS = -no-undefined \
+        -export-symbols-regex 'get_plugin' \
+        -version-info 1:0:0
+
+ldmsplugindir = ${libdir}/ovis-ldms
+ldmsplugin_LTLIBRARIES =
+
+# lustre ost plugin
+libllnl_lustre_ost_la_SOURCES = \
+	lustre_ost.c \
+	lustre_ost_general.c \
+	lustre_ost_job_stats.c \
+	lustre_ost.h \
+	lustre_ost_general.h \
+	lustre_ost_job_stats.h
+libllnl_lustre_ost_la_LIBADD = $(COMMON_LIBADD)
+libllnl_lustre_ost_la_LDFLAGS = $(COMMON_LDFLAGS)
+ldmsplugin_LTLIBRARIES += libllnl_lustre_ost.la
+
+# lustre mdt plugin
+libllnl_lustre_mdt_la_SOURCES = \
+	lustre_mdt.c \
+	lustre_mdt_general.c \
+	lustre_mdt_job_stats.c \
+	lustre_mdt.h \
+	lustre_mdt_general.h \
+	lustre_mdt_job_stats.h
+libllnl_lustre_mdt_la_LIBADD = $(COMMON_LIBADD)
+libllnl_lustre_mdt_la_LDFLAGS = $(COMMON_LDFLAGS)
+ldmsplugin_LTLIBRARIES += libllnl_lustre_mdt.la
+
+# lustre client plugin
+libllnl_lustre_client_la_SOURCES = \
+	lustre_client.c \
+	lustre_client_general.c \
+	lustre_client.h \
+	lustre_client_general.h
+libllnl_lustre_client_la_LIBADD = $(COMMON_LIBADD)
+libllnl_lustre_client_la_LDFLAGS = $(COMMON_LDFLAGS)
+ldmsplugin_LTLIBRARIES += libllnl_lustre_client.la
+
+if HAVE_DCGM
+# nvidia dcgm plugin
+libllnl_dcgm_la_SOURCES = dcgm.c
+libllnl_dcgm_la_LIBADD = $(COMMON_LIBADD) -ldcgm
+libllnl_dcgm_la_LDFLAGS = $(COMMON_LDFLAGS)
+ldmsplugin_LTLIBRARIES += libllnl_dcgm.la
+endif
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/dcgm.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/dcgm.c
new file mode 100644
index 00000000..8f726261
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/dcgm.c
@@ -0,0 +1,519 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <stdlib.h>
+#include <limits.h>
+#include <string.h>
+#include <dirent.h>
+#include <coll/rbt.h>
+#include <sys/queue.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include <dcgm_agent.h>
+
+#define _GNU_SOURCE
+
+#define SAMP "nvidia_dcgm"
+
+static unsigned short default_fields[] = {
+        DCGM_FI_DEV_GPU_TEMP,
+        DCGM_FI_DEV_POWER_USAGE,
+#if 0
+        DCGM_FI_PROF_GR_ENGINE_ACTIVE,
+        DCGM_FI_PROF_SM_ACTIVE,
+        DCGM_FI_PROF_SM_OCCUPANCY,
+        DCGM_FI_PROF_PIPE_TENSOR_ACTIVE,
+        DCGM_FI_PROF_DRAM_ACTIVE,
+        DCGM_FI_PROF_PIPE_FP64_ACTIVE,
+        DCGM_FI_PROF_PIPE_FP32_ACTIVE,
+        DCGM_FI_PROF_PIPE_FP16_ACTIVE,
+        DCGM_FI_PROF_PCIE_TX_BYTES,
+        DCGM_FI_PROF_PCIE_RX_BYTES,
+#endif
+#if 0
+        DCGM_FI_PROF_NVLINK_TX_BYTES,
+        DCGM_FI_PROF_NVLINK_RX_BYTES,
+#endif
+};
+
+static struct {
+        char *schema_name;
+        unsigned short *fields;
+        int fields_len;
+        long interval;
+} conf;
+
+static ldmsd_msg_log_f log_fn;
+static int dcgm_initialized = 0;
+static char producer_name[LDMS_PRODUCER_NAME_MAX];
+static short standalone = 1;
+static char *host_ip = "127.0.0.1";
+static dcgmGpuGrp_t gpu_group_id;
+static dcgmFieldGrp_t field_group_id;
+static int gpu_id_metric_index;
+static unsigned int gpu_ids[DCGM_MAX_NUM_DEVICES];
+static int gpu_ids_count;
+static ldms_schema_t gpu_schema;
+/* note that ldms_set_t is a pointer */
+/* NOTE: we are assuming here that GPU ids will start at zero and
+   not exceed the DCGM_MAX_NUM_DEVICES count in value */
+static ldms_set_t gpu_sets[DCGM_MAX_NUM_DEVICES];
+
+/* We won't use many of the entries in this array, but DCGM_FI_MAX_FIELDS is
+is only around 1000.  We trade off memory usage to allow quick translation of
+DCGM field ids to ldms index numbers. */
+static struct {
+        unsigned short ldms_type;
+        int ldms_index;
+} translation_table[DCGM_FI_MAX_FIELDS];
+
+static dcgmHandle_t dcgm_handle;
+
+/* returns ldms type */
+static unsigned short dcgm_to_ldms_type(unsigned short dcgm_field_type)
+{
+        switch (dcgm_field_type) {
+        case DCGM_FT_BINARY:
+                /* we do not handle dcgm binary blobs */
+                return LDMS_V_NONE;
+        case DCGM_FT_DOUBLE:
+                return LDMS_V_D64;
+        case DCGM_FT_INT64:
+                return LDMS_V_S64;
+        case DCGM_FT_STRING:
+                return LDMS_V_CHAR_ARRAY;
+        case DCGM_FT_TIMESTAMP:
+                return LDMS_V_S64;
+        default:
+                return LDMS_V_NONE;
+        }
+}
+
+static int sample_cb(unsigned int gpu_id, dcgmFieldValue_v1 *values,
+                                   int num_values, void *user_data)
+{
+        ldms_set_t set = gpu_sets[gpu_id];
+        int i;
+
+        for (i = 0; i < num_values; i++) {
+                dcgmFieldValue_v1 *value = &values[i];
+                int ldms_index = translation_table[value->fieldId].ldms_index;
+                int ldms_type = translation_table[value->fieldId].ldms_type;
+
+                if (dcgm_to_ldms_type(value->fieldType) != ldms_type) {
+                        log_fn(LDMSD_LERROR, SAMP" data type mismatch, "
+                               "field=%d, expected ldms=%d, received dcgm=%d\n",
+                               value->fieldId, ldms_type, value->fieldType);
+                        continue;
+                }
+
+                switch(value->fieldType) {
+                case DCGM_FT_BINARY:
+                        /* we do not handle binary blobs */
+                        break;
+                case DCGM_FT_DOUBLE:
+                        ldms_metric_set_double(set, ldms_index, value->value.dbl);
+                        break;
+                case DCGM_FT_INT64:
+                        ldms_metric_set_s64(set, ldms_index, value->value.i64);
+                        break;
+                case DCGM_FT_STRING:
+                        ldms_metric_array_set_str(set, ldms_index, value->value.str);
+                        break;
+                case DCGM_FT_TIMESTAMP:
+                        /* should this use value->ts instead?? */
+                        ldms_metric_set_s64(set, ldms_index, value->value.i64);
+                        break;
+                default:
+                        log_fn(LDMSD_LERROR, SAMP" unexpected data type, field=%d, received=%d\n",
+                               value->fieldType, value->fieldType);
+                        break;
+                }
+        }
+
+        return 0;
+}
+
+static int dcgm_init()
+{
+        dcgmReturn_t rc;
+
+        rc = dcgmInit();
+        if (rc != DCGM_ST_OK) {
+                log_fn(LDMSD_LERROR, SAMP" dcgmInit() failed: %s(%d)\n",
+                       errorString(rc), rc);
+                return -1;
+        }
+
+        if (standalone) {
+                rc = dcgmConnect(host_ip, &dcgm_handle);
+                if (rc != DCGM_ST_OK) {
+                        log_fn(LDMSD_LERROR, SAMP" dcgmConnect() failed: %s(%d)\n",
+                               errorString(rc), rc);
+                        return -1;
+                }
+        } else {
+                rc = dcgmStartEmbedded(DCGM_OPERATION_MODE_AUTO, &dcgm_handle);
+                if (rc != DCGM_ST_OK) {
+                        log_fn(LDMSD_LERROR, SAMP" dcgmStartEmbedded() failed: %s(%d)\n",
+                               errorString(rc), rc);
+                        return -1;
+                }
+        }
+
+        rc = dcgmGetAllSupportedDevices(dcgm_handle, gpu_ids, &gpu_ids_count);
+        if (rc != DCGM_ST_OK) {
+                log_fn(LDMSD_LERROR, SAMP" dcgmGetAllSupportedDevices() failed: %s(%d)\n",
+                       errorString(rc), rc);
+                return -1;
+        }
+        if (gpu_ids_count == 0) {
+                log_fn(LDMSD_LERROR, SAMP" no supported gpus found\n");
+                return -1;
+        }
+
+        /* Group tpye DCGM_GROUP_DEFAULT means all GPUs on the system */
+        rc = dcgmGroupCreate(dcgm_handle, DCGM_GROUP_DEFAULT,
+                             (char *)"ldmsd_group", &gpu_group_id);
+        if (rc != DCGM_ST_OK){
+                log_fn(LDMSD_LERROR, SAMP" dcgmGroupCreate failed: %s(%d)\n",
+                       errorString(rc), rc);
+                return -1;
+        }
+
+        rc = dcgmFieldGroupCreate(dcgm_handle, conf.fields_len, conf.fields,
+                                   (char *)"ldmsd_fields", &field_group_id);
+        if(rc != DCGM_ST_OK){
+                log_fn(LDMSD_LERROR, SAMP" dcgmFieldGroupCreate failed: %s(%d)\n",
+                       errorString(rc), rc);
+                return -1;
+        }
+
+        rc = dcgmWatchFields(dcgm_handle, gpu_group_id, field_group_id,
+                             conf.interval, (double)(conf.interval*3)/1000000, 50);
+        if (rc != DCGM_ST_OK){
+                log_fn(LDMSD_LERROR, SAMP" dcgmWatchFields failed: %s(%d)\n",
+                       errorString(rc), rc);
+                return -1;
+        }
+
+        dcgmUpdateAllFields(dcgm_handle, 1);
+
+        dcgm_initialized = 1;
+        return 0;
+}
+
+static void dcgm_fini()
+{
+        if (!dcgm_initialized)
+                return;
+        dcgmUnwatchFields(dcgm_handle, gpu_group_id, field_group_id);
+        dcgmFieldGroupDestroy(dcgm_handle, field_group_id);
+        dcgmGroupDestroy(dcgm_handle, gpu_group_id);
+        if(standalone) {
+                dcgmDisconnect(dcgm_handle);
+        } else {
+                dcgmStopEmbedded(dcgm_handle);
+        }
+        dcgmShutdown();
+        dcgm_initialized = 0;
+        /* clear translation table */
+}
+
+static ldms_set_t gpu_metric_set_create(int gpu_id)
+{
+        ldms_set_t set;
+        char instance_name[256];
+
+        log_fn(LDMSD_LDEBUG, SAMP" gpu_metric_set_create() (gpu %d)\n", gpu_id);
+
+        snprintf(instance_name, sizeof(instance_name), "%s/gpu_%d",
+                 producer_name, gpu_id);
+        set = ldms_set_new(instance_name, gpu_schema);
+        ldms_set_producer_name_set(set, producer_name);
+        ldms_metric_set_s32(set, gpu_id_metric_index, gpu_id);
+
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_publish(set);
+#endif
+
+        return set;
+}
+
+static void gpu_metric_set_destroy(ldms_set_t set)
+{
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_unpublish(set);
+#endif
+        ldms_set_delete(set);
+}
+
+
+static int gpu_schema_create()
+{
+        ldms_schema_t sch;
+        int rc;
+        int i;
+
+        log_fn(LDMSD_LDEBUG, SAMP" gpu_schema_create()\n");
+        sch = ldms_schema_new(conf.schema_name);
+        if (sch == NULL)
+                goto err1;
+        rc = ldms_schema_meta_add(sch, "gpu_id", LDMS_V_S32);
+        if (rc < 0)
+                goto err2;
+        gpu_id_metric_index = rc;
+
+        /* add gpu stats entries */
+        for (i = 0; i < conf.fields_len; i++) {
+                dcgm_field_meta_p field_meta;
+                unsigned short ldms_type;
+
+                field_meta = DcgmFieldGetById(conf.fields[i]);
+                ldms_type = dcgm_to_ldms_type(field_meta->fieldType);
+                rc = ldms_schema_metric_add(sch, field_meta->tag, ldms_type);
+                if (rc < 0)
+                        goto err2;
+                translation_table[conf.fields[i]].ldms_index = rc;
+                translation_table[conf.fields[i]].ldms_type = ldms_type;
+        }
+        gpu_schema = sch;
+
+        return 0;
+err2:
+        ldms_schema_delete(sch);
+err1:
+        log_fn(LDMSD_LERROR, SAMP" schema creation failed\n");
+        return -1;
+}
+
+static void gpu_schema_destroy()
+{
+        ldms_schema_delete(gpu_schema);
+        gpu_schema = NULL;
+}
+
+static int gpu_sample()
+{
+        int i;
+        int rc = 0;
+
+        for (i = 0; i < gpu_ids_count; i++) {
+                ldms_transaction_begin(gpu_sets[gpu_ids[i]]);
+        }
+        rc = dcgmGetLatestValues(dcgm_handle, gpu_group_id, field_group_id,
+                                 &sample_cb, NULL);
+        if (rc != DCGM_ST_OK){
+                /* TODO */
+                rc = -1;
+        }
+        for (i = 0; i < gpu_ids_count; i++) {
+                ldms_transaction_end(gpu_sets[gpu_ids[i]]);
+        }
+
+        return rc;
+}
+
+static int parse_fields_value(const char *fields_str, unsigned short **fields_out,
+                              int *fields_len_out)
+{
+        char *tmp_fields = NULL;
+        char *tmp;
+        char *saveptr;
+        char *token;
+        int count;
+        unsigned short *fields = NULL;
+
+        tmp_fields = strdup(fields_str);
+        if (tmp_fields == NULL) {
+                log_fn(LDMSD_LERROR, SAMP" parse_fields_value() strdup failed: %d", errno);
+                return -1;
+        }
+
+        for (count = 0, tmp = tmp_fields; ; count++, tmp = NULL) {
+                unsigned short *new_fields;
+
+                token = strtok_r(tmp, ",", &saveptr);
+                if (token == NULL)
+                        break;
+                new_fields = realloc(fields, sizeof(unsigned short)*(count+1));
+                if (new_fields == NULL) {
+                        log_fn(LDMSD_LERROR, SAMP" parse_fields_value() realloc failed: %d", errno);
+                        goto err1;
+                }
+                fields = new_fields;
+                errno = 0;
+                fields[count] = strtol(token, NULL, 10);
+                if (errno != 0) {
+                        log_fn(LDMSD_LERROR, SAMP" parse_fields_value() conversion error: %d\n", errno);
+                        goto err1;
+                }
+                if (fields[count] >= DCGM_FI_MAX_FIELDS) {
+                        log_fn(LDMSD_LERROR, SAMP" parse_fields_value() field values must be less than %d\n",
+                               DCGM_FI_MAX_FIELDS);
+                        goto err1;
+                }
+        }
+
+        free(tmp_fields);
+        *fields_out = fields;
+        *fields_len_out = count;
+        return 0;
+
+err1:
+        free(tmp_fields);
+        free(fields);
+        return -1;
+}
+
+/**************************************************************************
+ * Externally accessed functions
+ **************************************************************************/
+
+static int config(struct ldmsd_plugin *self,
+                  struct attr_value_list *kwl, struct attr_value_list *avl)
+{
+        char *value;
+        int rc = -1;
+        int i;
+
+        log_fn(LDMSD_LDEBUG, SAMP" config() called\n");
+
+        value = av_value(avl, "interval");
+        if (value == NULL) {
+                log_fn(LDMSD_LERROR, SAMP" config() \"interval\" option missing\n");
+                goto err0;
+        }
+        errno = 0;
+        conf.interval = strtol(value, NULL, 10);
+        if (errno != 0) {
+                log_fn(LDMSD_LERROR, SAMP" config() \"interval\" value conversion error: %d\n", errno);
+                goto err0;
+        }
+
+        value = av_value(avl, "schema");
+        if (value != NULL) {
+                conf.schema_name = strdup(value);
+        } else {
+                conf.schema_name = strdup("llnl_dcgm");
+        }
+        if (conf.schema_name == NULL) {
+                log_fn(LDMSD_LERROR, SAMP" config() strdup schema failed: %d", errno);
+                goto err0;
+        }
+
+        value = av_value(avl, "fields");
+        if (value != NULL) {
+                rc = parse_fields_value(value, &conf.fields, &conf.fields_len);
+                if (rc != 0) {
+                        goto err1;
+                }
+        } else {
+                /* use defaults */
+                conf.fields = malloc(sizeof(default_fields));
+                if (conf.fields == NULL) {
+                        log_fn(LDMSD_LERROR, SAMP" config() malloc of conf.fields failed");
+                        goto err1;
+                }
+                memcpy(conf.fields, default_fields, sizeof(default_fields));
+                conf.fields_len = sizeof(default_fields)/sizeof(default_fields[0]);
+        }
+
+        rc = dcgm_init();
+        if (rc != 0)
+                goto err2;
+        rc = gpu_schema_create();
+        if (rc != 0)
+                goto err3;
+        for (i = 0; i < gpu_ids_count; i++) {
+                if (gpu_ids[i] > DCGM_MAX_NUM_DEVICES) {
+                        log_fn(LDMSD_LERROR, SAMP" gpu id %d is greater than DCGM_MAX_NUM_DEVICES (%d), will require code fix\n");
+                        goto err4;
+                }
+                gpu_sets[gpu_ids[i]] = gpu_metric_set_create(gpu_ids[i]);
+        }
+
+        return 0;
+
+err4:
+        for (i = i-1; i >= 0; i--) {
+                gpu_metric_set_destroy(gpu_sets[gpu_ids[i]]);
+        }
+        gpu_schema_destroy();
+err3:
+        dcgm_fini();
+err2:
+        free(conf.fields);
+        conf.fields = NULL;
+        conf.fields_len = 0;
+        conf.interval = 0;
+err1:
+        free(conf.schema_name);
+        conf.schema_name = NULL;
+err0:
+        return rc;
+}
+
+static int sample(struct ldmsd_sampler *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" sample() called\n");
+        gpu_sample();
+        return 0;
+}
+
+static void term(struct ldmsd_plugin *self)
+{
+        int i;
+
+        free(conf.schema_name);
+        conf.schema_name = NULL;
+        free(conf.fields);
+        conf.fields = NULL;
+        conf.fields_len = 0;
+        conf.interval = 0;
+        for (i = 0; i < gpu_ids_count; i++) {
+                gpu_metric_set_destroy(gpu_sets[gpu_ids[i]]);
+        }
+        gpu_schema_destroy();
+        dcgm_fini();
+        log_fn(LDMSD_LDEBUG, SAMP" term() called\n");
+}
+
+static ldms_set_t get_set(struct ldmsd_sampler *self)
+{
+	return NULL;
+}
+
+static const char *usage(struct ldmsd_plugin *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" usage() called\n");
+	return  "config name=" SAMP;
+}
+
+static struct ldmsd_sampler nvidia_dcgm_plugin = {
+	.base = {
+		.name = SAMP,
+		.type = LDMSD_PLUGIN_SAMPLER,
+		.term = term,
+		.config = config,
+		.usage = usage,
+	},
+	.get_set = get_set,
+	.sample = sample,
+};
+
+struct ldmsd_plugin *get_plugin(ldmsd_msg_log_f pf)
+{
+        log_fn = pf;
+        log_fn(LDMSD_LDEBUG, SAMP" get_plugin() called\n");
+        gethostname(producer_name, sizeof(producer_name));
+
+        return &nvidia_dcgm_plugin.base;
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client.c
new file mode 100644
index 00000000..e818eb57
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client.c
@@ -0,0 +1,286 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <limits.h>
+#include <string.h>
+#include <dirent.h>
+#include <coll/rbt.h>
+#include <sys/queue.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_client.h"
+#include "lustre_client_general.h"
+
+#define _GNU_SOURCE
+
+/* locations where llite stats might be found */
+static const char * const llite_paths[] = {
+        "/proc/fs/lustre/llite",          /* lustre pre-2.12 */
+        "/sys/kernel/debug/lustre/llite"  /* lustre 2.12 and later */
+};
+static const int llite_paths_len = sizeof(llite_paths) / sizeof(llite_paths[0]);
+
+ldmsd_msg_log_f log_fn;
+char producer_name[LDMS_PRODUCER_NAME_MAX];
+
+/* red-black tree root for llites */
+static struct rbt llite_tree;
+
+struct llite_data {
+        char *fs_name;
+        char *name;
+        char *path;
+        char *stats_path;
+        ldms_set_t general_metric_set; /* a pointer */
+        struct rbn llite_tree_node;
+};
+
+static int string_comparator(void *a, const void *b)
+{
+        return strcmp((char *)a, (char *)b);
+}
+
+static struct llite_data *llite_create(const char *llite_name, const char *basedir)
+{
+        struct llite_data *llite;
+        char path_tmp[PATH_MAX];
+        char *state;
+
+        log_fn(LDMSD_LDEBUG, SAMP" llite_create() %s from %s\n",
+               llite_name, basedir);
+        llite = calloc(1, sizeof(*llite));
+        if (llite == NULL)
+                goto out1;
+        llite->name = strdup(llite_name);
+        if (llite->name == NULL)
+                goto out2;
+        snprintf(path_tmp, PATH_MAX, "%s/%s", basedir, llite_name);
+        llite->path = strdup(path_tmp);
+        if (llite->path == NULL)
+                goto out3;
+        snprintf(path_tmp, PATH_MAX, "%s/stats", llite->path);
+        llite->stats_path = strdup(path_tmp);
+        if (llite->stats_path == NULL)
+                goto out4;
+        llite->fs_name = strdup(llite_name);
+        if (llite->fs_name == NULL)
+                goto out5;
+        if (strtok_r(llite->fs_name, "-", &state) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to parse filesystem name from \"%s\"\n",
+                       llite->fs_name);
+                goto out6;
+        }
+        llite->general_metric_set = llite_general_create(producer_name,
+                                                         llite->fs_name,
+                                                         llite->name);
+        if (llite->general_metric_set == NULL)
+                goto out6;
+        rbn_init(&llite->llite_tree_node, llite->name);
+
+        return llite;
+out6:
+        free(llite->fs_name);
+out5:
+        free(llite->stats_path);
+out4:
+        free(llite->path);
+out3:
+        free(llite->name);
+out2:
+        free(llite);
+out1:
+        return NULL;
+}
+
+static void llite_destroy(struct llite_data *llite)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" llite_destroy() %s\n", llite->name);
+        llite_general_destroy(llite->general_metric_set);
+        free(llite->fs_name);
+        free(llite->stats_path);
+        free(llite->path);
+        free(llite->name);
+        free(llite);
+}
+
+static void llites_destroy()
+{
+        struct rbn *rbn;
+        struct llite_data *llite;
+
+        while (!rbt_empty(&llite_tree)) {
+                rbn = rbt_min(&llite_tree);
+                llite = container_of(rbn, struct llite_data,
+                                   llite_tree_node);
+                rbt_del(&llite_tree, rbn);
+                llite_destroy(llite);
+        }
+}
+
+/* Different versions of Lustre put the llite client stats in different place.
+   Returns a pointer to a path, or NULL if no llite directory found anywhere.
+ */
+static const char *const find_llite_path()
+{
+        static const char *previously_found_path = NULL;
+        struct stat sb;
+        int i;
+
+        for (i = 0; i < llite_paths_len; i++) {
+                if (stat(llite_paths[i], &sb) == -1 || !S_ISDIR(sb.st_mode))
+                        continue;
+                if (previously_found_path != llite_paths[i]) {
+                        /* just for logging purposes */
+                        previously_found_path = llite_paths[i];
+                        log_fn(LDMSD_LDEBUG, SAMP" find_llite_path() found %s\n",
+                               llite_paths[i]);
+                }
+                return llite_paths[i];
+        }
+
+        log_fn(LDMSD_LWARNING, SAMP" no llite directories found\n");
+        return NULL;
+}
+
+/* List subdirectories in llite_path to get list of
+   LLITE names.  Create llite_data structures for any LLITEs that we
+   have not seen, and delete any that we no longer see. */
+static void llites_refresh()
+{
+        const char *llite_path;
+        struct dirent *dirent;
+        DIR *dir;
+        struct rbt new_llite_tree;
+
+        llite_path = find_llite_path();
+        if (llite_path == NULL) {
+                return;
+        }
+
+        rbt_init(&new_llite_tree, string_comparator);
+
+        /* Make sure we have llite_data objects in the new_llite_tree for
+           each currently existing directory.  We can find the objects
+           cached in the global llite_tree (in which case we move them
+           from llite_tree to new_llite_tree), or they can be newly allocated
+           here. */
+        dir = opendir(llite_path);
+        if (dir == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to open llite dir %s\n",
+                       llite_path);
+                return;
+        }
+        while ((dirent = readdir(dir)) != NULL) {
+                struct rbn *rbn;
+                struct llite_data *llite;
+
+                if (dirent->d_type != DT_DIR ||
+                    strcmp(dirent->d_name, ".") == 0 ||
+                    strcmp(dirent->d_name, "..") == 0)
+                        continue;
+                rbn = rbt_find(&llite_tree, dirent->d_name);
+                if (rbn) {
+                        llite = container_of(rbn, struct llite_data,
+                                           llite_tree_node);
+                        rbt_del(&llite_tree, &llite->llite_tree_node);
+                } else {
+                        llite = llite_create(dirent->d_name, llite_path);
+                }
+                if (llite == NULL)
+                        continue;
+                rbt_ins(&new_llite_tree, &llite->llite_tree_node);
+        }
+        closedir(dir);
+
+        /* destroy any llites remaining in the global llite_tree since we
+           did not see their associated directories this time around */
+        llites_destroy();
+
+        /* copy the new_llite_tree into place over the global llite_tree */
+        memcpy(&llite_tree, &new_llite_tree, sizeof(struct rbt));
+
+        return;
+}
+
+static void llites_sample()
+{
+        struct rbn *rbn;
+
+        /* walk tree of known LLITEs */
+        RBT_FOREACH(rbn, &llite_tree) {
+                struct llite_data *llite;
+                llite = container_of(rbn, struct llite_data, llite_tree_node);
+                llite_general_sample(llite->name, llite->stats_path,
+                                   llite->general_metric_set);
+        }
+}
+
+static int config(struct ldmsd_plugin *self,
+                  struct attr_value_list *kwl, struct attr_value_list *avl)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" config() called\n");
+        return 0;
+}
+
+static int sample(struct ldmsd_sampler *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" sample() called\n");
+        if (llite_general_schema_is_initialized() < 0) {
+                if (llite_general_schema_init() < 0) {
+                        log_fn(LDMSD_LERROR, SAMP" general schema create failed\n");
+                        return ENOMEM;
+                }
+        }
+
+        llites_refresh();
+        llites_sample();
+
+        return 0;
+}
+
+static void term(struct ldmsd_plugin *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" term() called\n");
+        llites_destroy();
+        llite_general_schema_fini();
+}
+
+static ldms_set_t get_set(struct ldmsd_sampler *self)
+{
+	return NULL;
+}
+
+static const char *usage(struct ldmsd_plugin *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" usage() called\n");
+	return  "config name=" SAMP;
+}
+
+static struct ldmsd_sampler llite_plugin = {
+	.base = {
+		.name = SAMP,
+		.type = LDMSD_PLUGIN_SAMPLER,
+		.term = term,
+		.config = config,
+		.usage = usage,
+	},
+	.get_set = get_set,
+	.sample = sample,
+};
+
+struct ldmsd_plugin *get_plugin(ldmsd_msg_log_f pf)
+{
+        log_fn = pf;
+        log_fn(LDMSD_LDEBUG, SAMP" get_plugin() called\n");
+        rbt_init(&llite_tree, string_comparator);
+        gethostname(producer_name, sizeof(producer_name));
+
+        return &llite_plugin.base;
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client.h
new file mode 100644
index 00000000..75c6f5b9
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client.h
@@ -0,0 +1,23 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_LLITE_H
+#define __LUSTRE_LLITE_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+#define SAMP "lustre_client"
+
+extern ldmsd_msg_log_f log_fn;
+
+#ifndef RBT_FOREACH
+#define RBT_FOREACH(rbn, rbt) \
+        for ((rbn) = rbt_min((rbt)); (rbn); (rbn) = rbn_succ((rbn)))
+#endif
+
+#endif /* __LUSTRE_LLITE_H */
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client_general.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client_general.c
new file mode 100644
index 00000000..1412e8a6
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client_general.c
@@ -0,0 +1,216 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <dirent.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_client.h"
+#include "lustre_client_general.h"
+
+static ldms_schema_t llite_general_schema;
+
+static char *llite_stats_uint64_t_entries[] = {
+        "dirty_pages_hits",
+        "dirty_pages_misses",
+        "read_bytes.sum",
+        "write_bytes.sum",
+        "brw_read.sum",
+        "brw_write.sum",
+        "ioctl",
+        "open",
+        "close",
+        "mmap",
+        "page_fault",
+        "page_mkwrite",
+        "seek",
+        "fsync",
+        "readdir",
+        "setattr",
+        "truncate",
+        "flock",
+        "getattr",
+        "create",
+        "link",
+        "unlink",
+        "symlink",
+        "mkdir",
+        "rmdir",
+        "mknod",
+        "rename",
+        "statfs",
+        "alloc_inode",
+        "setxattr",
+        "getxattr",
+        "getxattr_hits",
+        "listxattr",
+        "removexattr",
+        "inode_permission",
+        NULL
+};
+
+int llite_general_schema_is_initialized()
+{
+        if (llite_general_schema != NULL)
+                return 0;
+        else
+                return -1;
+}
+
+int llite_general_schema_init(const char *producer_name)
+{
+        ldms_schema_t sch;
+        int rc;
+        int i;
+
+        log_fn(LDMSD_LDEBUG, SAMP" llite_general_schema_init()\n");
+        sch = ldms_schema_new("llnl_lustre_client");
+        if (sch == NULL)
+                goto err1;
+        rc = ldms_schema_meta_array_add(sch, "fs_name", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        rc = ldms_schema_meta_array_add(sch, "llite", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        /* add llite stats entries */
+        for (i = 0; llite_stats_uint64_t_entries[i] != NULL; i++) {
+                rc = ldms_schema_metric_add(sch, llite_stats_uint64_t_entries[i],
+                                            LDMS_V_U64);
+                if (rc < 0)
+                        goto err2;
+        }
+
+        llite_general_schema = sch;
+
+        return 0;
+err2:
+        ldms_schema_delete(sch);
+err1:
+        log_fn(LDMSD_LERROR, SAMP" lustre_llite_general schema creation failed\n");
+        return -1;
+}
+
+void llite_general_schema_fini()
+{
+        log_fn(LDMSD_LDEBUG, SAMP" llite_general_schema_fini()\n");
+        if (llite_general_schema != NULL) {
+                ldms_schema_delete(llite_general_schema);
+                llite_general_schema = NULL;
+        }
+}
+
+void llite_general_destroy(ldms_set_t set)
+{
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_unpublish(set);
+#endif
+        ldms_set_delete(set);
+}
+
+/* must be schema created by llite_general_schema_create() */
+ldms_set_t llite_general_create(const char *producer_name,
+                                const char *fs_name,
+                                const char *llite_name)
+{
+        ldms_set_t set;
+        int index;
+        char instance_name[256];
+
+        log_fn(LDMSD_LDEBUG, SAMP" llite_general_create()\n");
+        snprintf(instance_name, sizeof(instance_name), "%s/%s",
+                 producer_name, llite_name);
+        set = ldms_set_new(instance_name, llite_general_schema);
+        ldms_set_producer_name_set(set, producer_name);
+        index = ldms_metric_by_name(set, "fs_name");
+        ldms_metric_array_set_str(set, index, fs_name);
+        index = ldms_metric_by_name(set, "llite");
+        ldms_metric_array_set_str(set, index, llite_name);
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_publish(set);
+#endif
+
+        return set;
+}
+
+static void llite_stats_sample(const char *stats_path,
+                                   ldms_set_t general_metric_set)
+{
+        FILE *sf;
+        char buf[512];
+        char str1[64+1];
+
+        sf = fopen(stats_path, "r");
+        if (sf == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" file %s not found\n",
+                       stats_path);
+                return;
+        }
+
+        /* The first line should always be "snapshot_time"
+           we will ignore it because it always contains the time that we read
+           from the file, not any information about when the stats last
+           changed */
+        if (fgets(buf, sizeof(buf), sf) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" failed on read from %s\n",
+                       stats_path);
+                goto out1;
+        }
+        if (strncmp("snapshot_time", buf, sizeof("snapshot_time")-1) != 0) {
+                log_fn(LDMSD_LWARNING, SAMP" first line in %s is not \"snapshot_time\": %s\n",
+                       stats_path, buf);
+                goto out1;
+        }
+
+        ldms_transaction_begin(general_metric_set);
+        while (fgets(buf, sizeof(buf), sf)) {
+                uint64_t val1, val2;
+                int rc;
+                int index;
+
+                rc = sscanf(buf, "%64s %lu samples [%*[^]]] %*u %*u %lu",
+                            str1, &val1, &val2);
+                if (rc == 2) {
+                        index = ldms_metric_by_name(general_metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" llite stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(general_metric_set, index, val1);
+                        }
+                        continue;
+                } else if (rc == 3) {
+                        int base_name_len = strlen(str1);
+                        sprintf(str1+base_name_len, ".sum"); /* append ".sum" */
+                        index = ldms_metric_by_name(general_metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" llite stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(general_metric_set, index, val2);
+                        }
+                        continue;
+                }
+        }
+        ldms_transaction_end(general_metric_set);
+out1:
+        fclose(sf);
+
+        return;
+}
+
+void llite_general_sample(const char *llite_name, const char *stats_path,
+                          ldms_set_t general_metric_set)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" llite_general_sample() %s\n",
+               llite_name);
+        llite_stats_sample(stats_path, general_metric_set);
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client_general.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client_general.h
new file mode 100644
index 00000000..593121a8
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_client_general.h
@@ -0,0 +1,25 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_LLITE_GENERAL_H
+#define __LUSTRE_LLITE_GENERAL_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+int llite_general_schema_is_initialized();
+int llite_general_schema_init();
+void llite_general_schema_fini();
+ldms_set_t llite_general_create(const char *producer_name,
+                                const char *fs_name,
+                                const char *llite_name);
+char *llite_general_osd_path_find(const char *search_path, const char *llite_name);
+void llite_general_sample(const char *llite_name, const char *stats_path,
+                          ldms_set_t general_metric_set);
+void llite_general_destroy(ldms_set_t set);
+
+#endif /* __LUSTRE_LLITE_GENERAL_H */
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt.c
new file mode 100644
index 00000000..51b04097
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt.c
@@ -0,0 +1,272 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <limits.h>
+#include <string.h>
+#include <dirent.h>
+#include <coll/rbt.h>
+#include <sys/queue.h>
+#include <unistd.h>
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_mdt.h"
+#include "lustre_mdt_general.h"
+#include "lustre_mdt_job_stats.h"
+
+#define _GNU_SOURCE
+
+#define MDT_PATH "/proc/fs/lustre/mdt"
+#define OSD_SEARCH_PATH "/proc/fs/lustre"
+
+ldmsd_msg_log_f log_fn;
+char producer_name[LDMS_PRODUCER_NAME_MAX];
+
+/* red-black tree root for mdts */
+static struct rbt mdt_tree;
+
+struct mdt_data {
+        char *fs_name;
+        char *name;
+        char *path;
+        char *stats_path; /* md_stats */
+        char *job_stats_path;
+        char *osd_path;
+        ldms_set_t general_metric_set; /* a pointer */
+        struct rbn mdt_tree_node;
+        struct rbt job_stats; /* key is jobid */
+};
+
+static int string_comparator(void *a, const void *b)
+{
+        return strcmp((char *)a, (char *)b);
+}
+
+static struct mdt_data *mdt_create(const char *mdt_name, const char *basedir)
+{
+        struct mdt_data *mdt;
+        char path_tmp[PATH_MAX]; /* TODO: move large stack allocation to heap */
+        char *state;
+
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_create() %s from %s\n",
+               mdt_name, basedir);
+        mdt = calloc(1, sizeof(*mdt));
+        if (mdt == NULL)
+                goto out1;
+        mdt->name = strdup(mdt_name);
+        if (mdt->name == NULL)
+                goto out2;
+        snprintf(path_tmp, PATH_MAX, "%s/%s", basedir, mdt_name);
+        mdt->path = strdup(path_tmp);
+        if (mdt->path == NULL)
+                goto out3;
+        snprintf(path_tmp, PATH_MAX, "%s/md_stats", mdt->path);
+        mdt->stats_path = strdup(path_tmp);
+        if (mdt->stats_path == NULL)
+                goto out4;
+        snprintf(path_tmp, PATH_MAX, "%s/job_stats", mdt->path);
+        mdt->job_stats_path = strdup(path_tmp);
+        if (mdt->job_stats_path == NULL)
+                goto out5;
+        mdt->fs_name = strdup(mdt_name);
+        if (mdt->fs_name == NULL)
+                goto out6;
+        if (strtok_r(mdt->fs_name, "-", &state) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to parse filesystem name from \"%s\"\n",
+                       mdt->fs_name);
+                goto out7;
+        }
+        mdt->general_metric_set = mdt_general_create(producer_name, mdt->fs_name, mdt->name);
+        if (mdt->general_metric_set == NULL)
+                goto out7;
+        mdt->osd_path = mdt_general_osd_path_find(OSD_SEARCH_PATH, mdt->name);
+        rbn_init(&mdt->mdt_tree_node, mdt->name);
+        rbt_init(&mdt->job_stats, string_comparator);
+
+        return mdt;
+out7:
+        free(mdt->fs_name);
+out6:
+        free(mdt->job_stats_path);
+out5:
+        free(mdt->stats_path);
+out4:
+        free(mdt->path);
+out3:
+        free(mdt->name);
+out2:
+        free(mdt);
+out1:
+        return NULL;
+}
+
+static void mdt_destroy(struct mdt_data *mdt)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_destroy() %s\n", mdt->name);
+        mdt_general_destroy(mdt->general_metric_set);
+        mdt_job_stats_destroy(&mdt->job_stats);
+        free(mdt->osd_path);
+        free(mdt->fs_name);
+        free(mdt->job_stats_path);
+        free(mdt->stats_path);
+        free(mdt->path);
+        free(mdt->name);
+        free(mdt);
+}
+
+static void mdts_destroy()
+{
+        struct rbn *rbn;
+        struct mdt_data *mdt;
+
+        while (!rbt_empty(&mdt_tree)) {
+                rbn = rbt_min(&mdt_tree);
+                mdt = container_of(rbn, struct mdt_data,
+                                   mdt_tree_node);
+                rbt_del(&mdt_tree, rbn);
+                mdt_destroy(mdt);
+        }
+}
+
+/* List subdirectories in MDT_PATH to get list of
+   MDT names.  Create mdt_data structures for any MDTS any that we
+   have not seen, and delete any that we no longer see. */
+static void mdts_refresh()
+{
+        struct dirent *dirent;
+        DIR *dir;
+        struct rbt new_mdt_tree;
+
+        rbt_init(&new_mdt_tree, string_comparator);
+
+        /* Make sure we have mdt_data objects in the new_mdt_tree for
+           each currently existing directory.  We can find the objects
+           cached in the global mdt_tree (in which case we move them
+           from mdt_tree to new_mdt_tree), or they can be newly allocated
+           here. */
+
+        dir = opendir(MDT_PATH);
+        if (dir == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to open obdfilter dir %s\n",
+                       MDT_PATH);
+                return;
+        }
+        while ((dirent = readdir(dir)) != NULL) {
+                struct rbn *rbn;
+                struct mdt_data *mdt;
+
+                if (dirent->d_type != DT_DIR ||
+                    strcmp(dirent->d_name, ".") == 0 ||
+                    strcmp(dirent->d_name, "..") == 0)
+                        continue;
+                rbn = rbt_find(&mdt_tree, dirent->d_name);
+                if (rbn) {
+                        mdt = container_of(rbn, struct mdt_data,
+                                           mdt_tree_node);
+                        rbt_del(&mdt_tree, &mdt->mdt_tree_node);
+                } else {
+                        mdt = mdt_create(dirent->d_name, MDT_PATH);
+                }
+                if (mdt == NULL)
+                        continue;
+                rbt_ins(&new_mdt_tree, &mdt->mdt_tree_node);
+        }
+        closedir(dir);
+
+        /* destroy any mdts remaining in the global mdt_tree since we
+           did not see their associated directories this time around */
+        mdts_destroy();
+
+        /* copy the new_mdt_tree into place over the global mdt_tree */
+        memcpy(&mdt_tree, &new_mdt_tree, sizeof(struct rbt));
+
+        return;
+}
+
+static void mdts_sample()
+{
+        struct rbn *rbn;
+
+        /* walk tree of known MDTs */
+        RBT_FOREACH(rbn, &mdt_tree) {
+                struct mdt_data *mdt;
+                mdt = container_of(rbn, struct mdt_data, mdt_tree_node);
+                mdt_general_sample(mdt->name, mdt->stats_path, mdt->osd_path,
+                                   mdt->general_metric_set);
+                mdt_job_stats_sample(producer_name, mdt->fs_name, mdt->name,
+                                     mdt->job_stats_path, &mdt->job_stats);
+        }
+}
+
+static int config(struct ldmsd_plugin *self,
+                  struct attr_value_list *kwl, struct attr_value_list *avl)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" config() called\n");
+        return 0;
+}
+
+static int sample(struct ldmsd_sampler *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" sample() called\n");
+        if (mdt_general_schema_is_initialized() < 0) {
+                if (mdt_general_schema_init() < 0) {
+                        log_fn(LDMSD_LERROR, SAMP" general schema create failed\n");
+                        return ENOMEM;
+                }
+        }
+        if (mdt_job_stats_schema_is_initialized() < 0) {
+                if (mdt_job_stats_schema_init() < 0) {
+                        log_fn(LDMSD_LERROR, SAMP" job stats schema create failed\n");
+                        return ENOMEM;
+                }
+        }
+
+        mdts_refresh();
+        mdts_sample();
+
+        return 0;
+}
+
+static void term(struct ldmsd_plugin *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" term() called\n");
+        mdts_destroy();
+        mdt_general_schema_fini();
+        mdt_job_stats_schema_fini();
+}
+
+static ldms_set_t get_set(struct ldmsd_sampler *self)
+{
+	return NULL;
+}
+
+static const char *usage(struct ldmsd_plugin *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" usage() called\n");
+	return  "config name=" SAMP;
+}
+
+static struct ldmsd_sampler mdt_job_stats_plugin = {
+	.base = {
+		.name = SAMP,
+		.type = LDMSD_PLUGIN_SAMPLER,
+		.term = term,
+		.config = config,
+		.usage = usage,
+	},
+	.get_set = get_set,
+	.sample = sample,
+};
+
+struct ldmsd_plugin *get_plugin(ldmsd_msg_log_f pf)
+{
+        log_fn = pf;
+        log_fn(LDMSD_LDEBUG, SAMP" get_plugin() called\n");
+        rbt_init(&mdt_tree, string_comparator);
+        gethostname(producer_name, sizeof(producer_name));
+
+        return &mdt_job_stats_plugin.base;
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt.h
new file mode 100644
index 00000000..7a7132dd
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt.h
@@ -0,0 +1,23 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_MDT_H
+#define __LUSTRE_MDT_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+#define SAMP "lustre_mdt"
+
+extern ldmsd_msg_log_f log_fn;
+
+#ifndef RBT_FOREACH
+#define RBT_FOREACH(rbn, rbt) \
+        for ((rbn) = rbt_min((rbt)); (rbn); (rbn) = rbn_succ((rbn)))
+#endif
+
+#endif /* __LUSTRE_MDT_H */
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_general.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_general.c
new file mode 100644
index 00000000..2994273d
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_general.c
@@ -0,0 +1,301 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <dirent.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_mdt.h"
+#include "lustre_mdt_general.h"
+
+static ldms_schema_t mdt_general_schema;
+
+static char *mdt_md_stats_uint64_t_entries[] = {
+        "open",
+        "close",
+        "close.sum",
+        "mknod",
+        "mknod.sum",
+        "link",
+        "unlink",
+        "mkdir",
+        "rmdir",
+        "rename",
+        "getattr",
+        "setattr",
+        "getxattr",
+        "setxattr",
+        "statfs",
+        "sync",
+        "samedir_rename",
+        "crossdir_rename",
+        NULL
+};
+
+static char *osd_uint64_t_fields[] = {
+        "filesfree",
+        "filestotal",
+        "kbytesavail",
+        "kbytesfree",
+        "kbytestotal",
+        NULL
+};
+
+int mdt_general_schema_is_initialized()
+{
+        if (mdt_general_schema != NULL)
+                return 0;
+        else
+                return -1;
+}
+
+int mdt_general_schema_init(const char *producer_name)
+{
+        ldms_schema_t sch;
+        int rc;
+        int i;
+
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_general_schema_init()\n");
+        sch = ldms_schema_new("llnl_lustre_mdt");
+        if (sch == NULL)
+                goto err1;
+        rc = ldms_schema_meta_array_add(sch, "fs_name", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        rc = ldms_schema_meta_array_add(sch, "mdt", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        /* add mdt md_stats entries */
+        for (i = 0; mdt_md_stats_uint64_t_entries[i] != NULL; i++) {
+                rc = ldms_schema_metric_add(sch, mdt_md_stats_uint64_t_entries[i],
+                                            LDMS_V_U64);
+                if (rc < 0)
+                        goto err2;
+        }
+        /* add osd entries */
+        for (i = 0; osd_uint64_t_fields[i] != NULL; i++) {
+                rc = ldms_schema_metric_add(sch, osd_uint64_t_fields[i],
+                                            LDMS_V_U64);
+                if (rc < 0)
+                        goto err2;
+        }
+
+        mdt_general_schema = sch;
+
+        return 0;
+err2:
+        ldms_schema_delete(sch);
+err1:
+        log_fn(LDMSD_LERROR, SAMP" lustre_mdt_general schema creation failed\n");
+        return -1;
+}
+
+void mdt_general_schema_fini()
+{
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_general_schema_fini()\n");
+        if (mdt_general_schema != NULL) {
+                ldms_schema_delete(mdt_general_schema);
+                mdt_general_schema = NULL;
+        }
+}
+
+/* Returns strdup'ed string or NULL.  Caller must free. */
+char *mdt_general_osd_path_find(const char *search_path, const char *mdt_name)
+{
+        struct dirent *dirent;
+        DIR *dir;
+        char *osd_path = NULL;
+
+        dir = opendir(search_path);
+        if (dir == NULL) {
+                return NULL;
+        }
+
+        while ((dirent = readdir(dir)) != NULL) {
+                if (dirent->d_type == DT_DIR &&
+                    strncmp(dirent->d_name, "osd-", strlen("osd-")) == 0) {
+                        char tmp_path[PATH_MAX];
+                        snprintf(tmp_path, PATH_MAX, "%s/%s/%s",
+                                 search_path, dirent->d_name, mdt_name);
+                        if (access(tmp_path, F_OK) == 0) {
+                                osd_path = strdup(tmp_path);
+                                break;
+                        }
+                }
+        }
+
+        closedir(dir);
+
+        if (osd_path != NULL) {
+                log_fn(LDMSD_LDEBUG, SAMP" for mdt %s found osd path %s\n",
+                       mdt_name, osd_path);
+        } else {
+                log_fn(LDMSD_LWARNING, SAMP" osd for mdt %s not found\n",
+                       mdt_name);
+        }
+
+        return osd_path;
+}
+
+static uint64_t file_read_uint64_t(const char *dir, const char *file)
+{
+        uint64_t val;
+        char filepath[PATH_MAX];
+        char valbuf[64];
+        FILE *fp;
+
+        snprintf(filepath, PATH_MAX, "%s/%s", dir, file);
+        fp = fopen(filepath, "r");
+        if (fp == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to open %s\n", filepath);
+                return 0;
+        }
+        if (fgets(valbuf, sizeof(valbuf), fp) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to read %s\n", filepath);
+                fclose(fp);
+                return 0;
+        }
+        fclose(fp);
+
+        /* turn string into int */
+        sscanf(valbuf, "%lu", &val);
+
+        return val;
+}
+
+static void osd_sample(const char *osd_path, ldms_set_t general_metric_set)
+{
+        char *field;
+        uint64_t val;
+        int index;
+        int i;
+
+        for (i = 0; (field = osd_uint64_t_fields[i]) != NULL; i++) {
+                val = file_read_uint64_t(osd_path, field);
+                index = ldms_metric_by_name(general_metric_set, field);
+                ldms_metric_set_u64(general_metric_set, index, val);
+         }
+}
+
+
+void mdt_general_destroy(ldms_set_t set)
+{
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_unpublish(set);
+#endif
+        ldms_set_delete(set);
+}
+
+
+/* must be schema created by mdt_general_schema_create() */
+ldms_set_t mdt_general_create(const char *producer_name, const char *fs_name,
+                              const char *mdt_name)
+{
+        ldms_set_t set;
+        int index;
+        char instance_name[256];
+
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_general_create()\n");
+        snprintf(instance_name, sizeof(instance_name), "%s/%s",
+                 producer_name, mdt_name);
+        set = ldms_set_new(instance_name, mdt_general_schema);
+        ldms_set_producer_name_set(set, producer_name);
+        index = ldms_metric_by_name(set, "fs_name");
+        ldms_metric_array_set_str(set, index, fs_name);
+        index = ldms_metric_by_name(set, "mdt");
+        ldms_metric_array_set_str(set, index, mdt_name);
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_publish(set);
+#endif
+        return set;
+}
+
+static void mdt_md_stats_sample(const char *stats_path,
+                                   ldms_set_t general_metric_set)
+{
+        FILE *sf;
+        char buf[512];
+        char str1[64+1];
+
+        sf = fopen(stats_path, "r");
+        if (sf == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" file %s not found\n",
+                       stats_path);
+                return;
+        }
+
+        /* The first line should always be "snapshot_time"
+           we will ignore it because it always contains the time that we read
+           from the file, not any information about when the stats last
+           changed */
+        if (fgets(buf, sizeof(buf), sf) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" failed on read from %s\n",
+                       stats_path);
+                goto out1;
+        }
+        if (strncmp("snapshot_time", buf, sizeof("snapshot_time")-1) != 0) {
+                log_fn(LDMSD_LWARNING, SAMP" first line in %s is not \"snapshot_time\": %s\n",
+                       stats_path, buf);
+                goto out1;
+        }
+
+        ldms_transaction_begin(general_metric_set);
+        while (fgets(buf, sizeof(buf), sf)) {
+                uint64_t val1, val2;
+                int rc;
+                int index;
+
+                rc = sscanf(buf, "%64s %lu samples [%*[^]]] %*u %*u %lu",
+                            str1, &val1, &val2);
+                if (rc == 2) {
+                        index = ldms_metric_by_name(general_metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" mdt md_stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(general_metric_set, index, val1);
+                        }
+                        continue;
+                } else if (rc == 3) {
+                        int base_name_len = strlen(str1);
+                        index = ldms_metric_by_name(general_metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" mdt md_stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(general_metric_set, index, val1);
+                        }
+                        sprintf(str1+base_name_len, ".sum"); /* append ".sum" */
+                        index = ldms_metric_by_name(general_metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" mdt md_stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(general_metric_set, index, val2);
+                        }
+                        continue;
+                }
+        }
+        ldms_transaction_end(general_metric_set);
+out1:
+        fclose(sf);
+
+        return;
+}
+
+void mdt_general_sample(const char *mdt_name, const char *stats_path,
+                        const char *osd_path, ldms_set_t general_metric_set)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_general_sample() %s\n",
+               mdt_name);
+        mdt_md_stats_sample(stats_path, general_metric_set);
+        osd_sample(osd_path, general_metric_set);
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_general.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_general.h
new file mode 100644
index 00000000..600196e3
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_general.h
@@ -0,0 +1,24 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_MDT_GENERAL_H
+#define __LUSTRE_MDT_GENERAL_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+int mdt_general_schema_is_initialized();
+int mdt_general_schema_init();
+void mdt_general_schema_fini();
+ldms_set_t mdt_general_create(const char *producer_name, const char *fs_name,
+                              const char *mdt_name);
+char *mdt_general_osd_path_find(const char *search_path, const char *mdt_name);
+void mdt_general_sample(const char *mdt_name, const char *stats_path,
+                        const char *osd_path, ldms_set_t general_metric_set);
+void mdt_general_destroy(ldms_set_t set);
+
+#endif /* __LUSTRE_MDT_GENERAL_H */
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_job_stats.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_job_stats.c
new file mode 100644
index 00000000..1bc9090c
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_job_stats.c
@@ -0,0 +1,327 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_mdt.h"
+#include "lustre_mdt_job_stats.h"
+
+/* ldms_schema_t is a pointer */
+static ldms_schema_t mdt_job_stats_schema;
+
+struct mdt_job_stats_data {
+        char *jobid;
+        uint64_t prev_snapshot_time;
+        ldms_set_t metric_set; /* a pointer */
+        struct rbn job_stats_node;
+};
+
+static char *job_stats_uint64_t_entries[] = {
+        "snapshot_time",
+        "open",
+        "close",
+        "mknod",
+        "link",
+        "unlink",
+        "mkdir",
+        "rmdir",
+        "rename",
+        "getattr",
+        "setattr",
+        "getxattr",
+        "setxattr",
+        "statfs",
+        "sync",
+        "samedir_rename",
+        "crossdir_rename",
+        "read_bytes_sum",
+        "write_bytes_sum",
+        "punch",
+        NULL
+};
+
+static int string_comparator(void *a, const void *b)
+{
+        return strcmp((char *)a, (char *)b);
+}
+
+int mdt_job_stats_schema_is_initialized()
+{
+        if (mdt_job_stats_schema != NULL)
+                return 0;
+        else
+                return -1;
+}
+
+
+int mdt_job_stats_schema_init(const char *producer_name)
+{
+        /* ldms_schema_t is a pointer */
+        ldms_schema_t sch;
+        int i;
+        int rc;
+
+        sch = ldms_schema_new("llnl_lustre_mdt_job_stats");
+        if (sch == NULL)
+                goto err1;
+        rc = ldms_schema_meta_array_add(sch, "fs_name", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        rc = ldms_schema_meta_array_add(sch, "mdt", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        rc = ldms_schema_meta_array_add(sch, "job_id", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        for (i = 0; job_stats_uint64_t_entries[i] != NULL; i++) {
+                rc = ldms_schema_metric_add(sch, job_stats_uint64_t_entries[i],
+                                            LDMS_V_U64);
+                if (rc < 0)
+                        goto err2;
+        }
+
+        mdt_job_stats_schema = sch;
+
+        return 0;
+err2:
+        ldms_schema_delete(sch);
+err1:
+        log_fn(LDMSD_LERROR, SAMP" lustre_mdt_job_stats schema creation failed\n");
+        return -1;
+}
+
+void mdt_job_stats_schema_fini()
+{
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_job_stats_schema_fini()\n");
+        if (mdt_job_stats_schema != NULL) {
+                ldms_schema_delete(mdt_job_stats_schema);
+                mdt_job_stats_schema = NULL;
+        }
+}
+
+static struct mdt_job_stats_data *mdt_job_stats_data_create(const char *producer_name,
+                                                            const char *jobid,
+                                                            const char *fs_name,
+                                                            const char *mdt_name)
+{
+        struct mdt_job_stats_data *job_stats;
+        int index;
+        char instance_name[256];
+
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_job_stats_data_create() jobid=%s\n",
+               jobid);
+        job_stats = calloc(1, sizeof(*job_stats));
+        if (job_stats == NULL)
+                goto out1;
+        job_stats->jobid = strdup(jobid);
+        if (job_stats->jobid == NULL)
+                goto out2;
+        snprintf(instance_name, sizeof(instance_name), "%s/%s/%s",
+                 producer_name, mdt_name, jobid);
+        job_stats->metric_set = ldms_set_new(instance_name,
+                                             mdt_job_stats_schema);
+        if (job_stats->metric_set == NULL)
+                goto out3;
+        rbn_init(&job_stats->job_stats_node, job_stats->jobid);
+
+        ldms_set_producer_name_set(job_stats->metric_set, producer_name);
+        index = ldms_metric_by_name(job_stats->metric_set, "fs_name");
+        ldms_metric_array_set_str(job_stats->metric_set, index, fs_name);
+        index = ldms_metric_by_name(job_stats->metric_set, "mdt");
+        ldms_metric_array_set_str(job_stats->metric_set, index, mdt_name);
+        index = ldms_metric_by_name(job_stats->metric_set, "job_id");
+        ldms_metric_array_set_str(job_stats->metric_set, index, jobid);
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_publish(job_stats->metric_set);
+#endif
+        return job_stats;
+out3:
+        free(job_stats->jobid);
+out2:
+        free(job_stats);
+out1:
+        log_fn(LDMSD_LERROR, SAMP" mdt_job_stats_data_create failed\n");
+        return NULL;
+}
+
+static void mdt_job_stats_data_destroy(struct mdt_job_stats_data *job_stats)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_job_stats_data_destroy() jobid=%s\n",
+               job_stats->jobid);
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_unpublish(job_stats->metric_set);
+#endif
+        ldms_set_delete(job_stats->metric_set);
+        free(job_stats->jobid);
+        free(job_stats);
+}
+
+void mdt_job_stats_destroy(struct rbt *job_stats_tree)
+{
+        struct rbn *rbn;
+        struct mdt_job_stats_data *job_stats;
+
+        while (!rbt_empty(job_stats_tree)) {
+                rbn = rbt_min(job_stats_tree);
+                job_stats = container_of(rbn, struct mdt_job_stats_data,
+                                         job_stats_node);
+                rbt_del(job_stats_tree, rbn);
+                mdt_job_stats_data_destroy(job_stats);
+        }
+}
+
+static void job_stats_sample_stop(struct mdt_job_stats_data **job_stats)
+{
+        if (*job_stats != NULL) {
+                if (!ldms_set_is_consistent((*job_stats)->metric_set)) {
+                        ldms_transaction_end((*job_stats)->metric_set);
+                }
+                *job_stats = NULL;
+        }
+}
+
+/* Read job_stats file, and for each seen jobid:
+
+   1) If we have not seen the jobid before, create the associated
+      metric set.
+   2) Update the metrics in the metric set.
+
+   We also need to track which jobids are not seen so that we may
+   destroy that metric set which is no longer needed.  We assume
+   that we can remove the metric set immediately because lustre
+   leaves the jobid around for a while.  The amount of time is
+   configurable in job_cleanup_interval, and defaults to 600 seconds.
+   As long as the job_cleanup_interval in Lustre is sufficently longer
+   than the ldms aggregator polling interval, there is no need for
+   additional caching in ldms.
+*/
+void mdt_job_stats_sample(const char *producer_name, const char *fs_name,
+                          const char *mdt_name, const char *job_stats_path,
+                          struct rbt *job_stats_tree)
+{
+        FILE *js; /* job_stats */
+        char buf[512];
+        struct rbt new_job_stats;
+        struct mdt_job_stats_data *job_stats = NULL;
+
+        log_fn(LDMSD_LDEBUG, SAMP" mdt_job_stats_sample() %s\n",
+               mdt_name);
+        js = fopen(job_stats_path, "r");
+        if (js == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" file %s not found\n",
+                       job_stats_path);
+                return;
+        }
+
+        /* The first line should always be "job_stats:" */
+        if (fgets(buf, sizeof(buf), js) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" failed on read from %s\n",
+                       job_stats_path);
+                goto out1;
+        }
+        if (strncmp("job_stats:", buf, sizeof("job_stats:")-1) != 0) {
+                log_fn(LDMSD_LWARNING, SAMP" first line in %s is not \"job_stats:\": %s\n",
+                       job_stats_path, buf);
+                goto out1;
+        }
+
+        rbt_init(&new_job_stats, string_comparator);
+        /* start new empty rbt for job stats we see this time */
+        while (fgets(buf, sizeof(buf), js)) {
+                char str1[64+1];
+                uint64_t val1;
+                int rc;
+                int index;
+
+                rc = sscanf(buf, " - job_id: %s", str1);
+                if (rc == 1) {
+                        struct rbn *rbn;
+
+                        job_stats_sample_stop(&job_stats);
+                        rbn = rbt_find(job_stats_tree, str1);
+                        if (rbn) {
+                                job_stats = container_of(rbn, struct mdt_job_stats_data, job_stats_node);
+                                rbt_del(job_stats_tree, &job_stats->job_stats_node);
+                        } else {
+                                job_stats = mdt_job_stats_data_create(producer_name, str1, fs_name, mdt_name);
+                        }
+                        if (job_stats != NULL) {
+                                rbt_ins(&new_job_stats, &job_stats->job_stats_node);
+                        }
+                        continue;
+                }
+                if (job_stats == NULL) {
+                        /* We must have failed to find or allocate the job_stats
+                           structure, so we have no where to put metrics.  We'll
+                           just skip everything until we see the next job_id
+                           section in the file. */
+                        continue;
+                }
+                rc = sscanf(buf, " snapshot_time: %lu", &val1);
+                if (rc == 1) {
+                        /* only update the metric if a change of snapshot time
+                           tells us that the data has changed */
+                        if (job_stats->prev_snapshot_time == val1)
+                                continue;
+                        log_fn(LDMSD_LDEBUG, SAMP" jobid %s has updated data\n",
+                               job_stats->jobid);
+                        job_stats->prev_snapshot_time = val1;
+                        ldms_transaction_begin(job_stats->metric_set);
+                        index = ldms_metric_by_name(job_stats->metric_set, "snapshot_time");
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" mdt job_stats metric not found: snapshot_time\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(job_stats->metric_set, index, val1);
+                        }
+                        continue;
+                }
+                if (ldms_set_is_consistent(job_stats->metric_set)) {
+                        /* We recognized the jobid, but the data hasn't changed,
+                           so just ignore the data lines */
+                        continue;
+                }
+                rc = sscanf(buf, " %64[^:]: { samples: %*u, unit: bytes, min: %*u, max: %*u, sum: %lu }",
+                            str1, &val1);
+                if (rc == 2) {
+                        int base_name_len = strlen(str1);
+                        sprintf(str1+base_name_len, "_sum");
+                        index = ldms_metric_by_name(job_stats->metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" mdt job_stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(job_stats->metric_set, index, val1);
+                        }
+                        continue;
+                }
+                rc = sscanf(buf, " %64[^:]: { samples: %lu",
+                            str1, &val1);
+                if (rc == 2) {
+                        index = ldms_metric_by_name(job_stats->metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" mdt job_stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(job_stats->metric_set, index, val1);
+                        }
+                        continue;
+                }
+        }
+        job_stats_sample_stop(&job_stats);
+
+        /* destroy any remaining job_stats since we didn't see them this
+           time (if we had, they would have been moved to new_job_stats) */
+        mdt_job_stats_destroy(job_stats_tree);
+
+        /* swap new rbt into old rbt's place */
+        memcpy(job_stats_tree, &new_job_stats, sizeof(struct rbt));
+out1:
+        fclose(js);
+
+        return;
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_job_stats.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_job_stats.h
new file mode 100644
index 00000000..3947de62
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_mdt_job_stats.h
@@ -0,0 +1,22 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_MDT_JOB_STATS_H
+#define __LUSTRE_MDT_JOB_STATS_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+int mdt_job_stats_schema_is_initialized();
+int mdt_job_stats_schema_init();
+void mdt_job_stats_schema_fini();
+void mdt_job_stats_sample(const char *producer_name, const char *fs_name,
+                          const char *mdt_name, const char *job_stats_path,
+                          struct rbt *job_stats_tree);
+void mdt_job_stats_destroy(struct rbt *job_stats_tree);
+
+#endif /* __LUSTRE_MDT_JOB_STATS_H */
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost.c
new file mode 100644
index 00000000..e8c58e93
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost.c
@@ -0,0 +1,272 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <limits.h>
+#include <string.h>
+#include <dirent.h>
+#include <coll/rbt.h>
+#include <sys/queue.h>
+#include <unistd.h>
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_ost.h"
+#include "lustre_ost_general.h"
+#include "lustre_ost_job_stats.h"
+
+#define _GNU_SOURCE
+
+#define OBDFILTER_PATH "/proc/fs/lustre/obdfilter"
+#define OSD_SEARCH_PATH "/proc/fs/lustre"
+
+ldmsd_msg_log_f log_fn;
+char producer_name[LDMS_PRODUCER_NAME_MAX];
+
+/* red-black tree root for osts */
+static struct rbt ost_tree;
+
+struct ost_data {
+        char *fs_name;
+        char *name;
+        char *path;
+        char *stats_path;
+        char *job_stats_path;
+        char *osd_path;
+        ldms_set_t general_metric_set; /* a pointer */
+        struct rbn ost_tree_node;
+        struct rbt job_stats; /* key is jobid */
+};
+
+static int string_comparator(void *a, const void *b)
+{
+        return strcmp((char *)a, (char *)b);
+}
+
+static struct ost_data *ost_create(const char *ost_name, const char *basedir)
+{
+        struct ost_data *ost;
+        char path_tmp[PATH_MAX]; /* TODO: move large stack allocation to heap */
+        char *state;
+
+        log_fn(LDMSD_LDEBUG, SAMP" ost_create() %s from %s\n",
+               ost_name, basedir);
+        ost = calloc(1, sizeof(*ost));
+        if (ost == NULL)
+                goto out1;
+        ost->name = strdup(ost_name);
+        if (ost->name == NULL)
+                goto out2;
+        snprintf(path_tmp, PATH_MAX, "%s/%s", basedir, ost_name);
+        ost->path = strdup(path_tmp);
+        if (ost->path == NULL)
+                goto out3;
+        snprintf(path_tmp, PATH_MAX, "%s/stats", ost->path);
+        ost->stats_path = strdup(path_tmp);
+        if (ost->stats_path == NULL)
+                goto out4;
+        snprintf(path_tmp, PATH_MAX, "%s/job_stats", ost->path);
+        ost->job_stats_path = strdup(path_tmp);
+        if (ost->job_stats_path == NULL)
+                goto out5;
+        ost->fs_name = strdup(ost_name);
+        if (ost->fs_name == NULL)
+                goto out6;
+        if (strtok_r(ost->fs_name, "-", &state) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to parse filesystem name from \"%s\"\n",
+                       ost->fs_name);
+                goto out7;
+        }
+        ost->general_metric_set = ost_general_create(producer_name, ost->fs_name, ost->name);
+        if (ost->general_metric_set == NULL)
+                goto out7;
+        ost->osd_path = ost_general_osd_path_find(OSD_SEARCH_PATH, ost->name);
+        rbn_init(&ost->ost_tree_node, ost->name);
+        rbt_init(&ost->job_stats, string_comparator);
+
+        return ost;
+out7:
+        free(ost->fs_name);
+out6:
+        free(ost->job_stats_path);
+out5:
+        free(ost->stats_path);
+out4:
+        free(ost->path);
+out3:
+        free(ost->name);
+out2:
+        free(ost);
+out1:
+        return NULL;
+}
+
+static void ost_destroy(struct ost_data *ost)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" ost_destroy() %s\n", ost->name);
+        ost_general_destroy(ost->general_metric_set);
+        ost_job_stats_destroy(&ost->job_stats);
+        free(ost->osd_path);
+        free(ost->fs_name);
+        free(ost->job_stats_path);
+        free(ost->stats_path);
+        free(ost->path);
+        free(ost->name);
+        free(ost);
+}
+
+static void osts_destroy()
+{
+        struct rbn *rbn;
+        struct ost_data *ost;
+
+        while (!rbt_empty(&ost_tree)) {
+                rbn = rbt_min(&ost_tree);
+                ost = container_of(rbn, struct ost_data,
+                                   ost_tree_node);
+                rbt_del(&ost_tree, rbn);
+                ost_destroy(ost);
+        }
+}
+
+/* List subdirectories in OBDFILTER_PATH to get list of
+   OST names.  Create ost_data structures for any OSTS any that we
+   have not seen, and delete any that we no longer see. */
+static void osts_refresh()
+{
+        struct dirent *dirent;
+        DIR *dir;
+        struct rbt new_ost_tree;
+
+        rbt_init(&new_ost_tree, string_comparator);
+
+        /* Make sure we have ost_data objects in the new_ost_tree for
+           each currently existing directory.  We can find the objects
+           cached in the global ost_tree (in which case we move them
+           from ost_tree to new_ost_tree), or they can be newly allocated
+           here. */
+
+        dir = opendir(OBDFILTER_PATH);
+        if (dir == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to open obdfilter dir %s\n",
+                       OBDFILTER_PATH);
+                return;
+        }
+        while ((dirent = readdir(dir)) != NULL) {
+                struct rbn *rbn;
+                struct ost_data *ost;
+
+                if (dirent->d_type != DT_DIR ||
+                    strcmp(dirent->d_name, ".") == 0 ||
+                    strcmp(dirent->d_name, "..") == 0)
+                        continue;
+                rbn = rbt_find(&ost_tree, dirent->d_name);
+                if (rbn) {
+                        ost = container_of(rbn, struct ost_data,
+                                           ost_tree_node);
+                        rbt_del(&ost_tree, &ost->ost_tree_node);
+                } else {
+                        ost = ost_create(dirent->d_name, OBDFILTER_PATH);
+                }
+                if (ost == NULL)
+                        continue;
+                rbt_ins(&new_ost_tree, &ost->ost_tree_node);
+        }
+        closedir(dir);
+
+        /* destroy any osts remaining in the global ost_tree since we
+           did not see their associated directories this time around */
+        osts_destroy();
+
+        /* copy the new_ost_tree into place over the global ost_tree */
+        memcpy(&ost_tree, &new_ost_tree, sizeof(struct rbt));
+
+        return;
+}
+
+static void osts_sample()
+{
+        struct rbn *rbn;
+
+        /* walk tree of known OSTs */
+        RBT_FOREACH(rbn, &ost_tree) {
+                struct ost_data *ost;
+                ost = container_of(rbn, struct ost_data, ost_tree_node);
+                ost_general_sample(ost->name, ost->stats_path, ost->osd_path,
+                                   ost->general_metric_set);
+                ost_job_stats_sample(producer_name, ost->fs_name, ost->name,
+                                     ost->job_stats_path, &ost->job_stats);
+        }
+}
+
+static int config(struct ldmsd_plugin *self,
+                  struct attr_value_list *kwl, struct attr_value_list *avl)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" config() called\n");
+        return 0;
+}
+
+static int sample(struct ldmsd_sampler *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" sample() called\n");
+        if (ost_general_schema_is_initialized() < 0) {
+                if (ost_general_schema_init() < 0) {
+                        log_fn(LDMSD_LERROR, SAMP" general schema create failed\n");
+                        return ENOMEM;
+                }
+        }
+        if (ost_job_stats_schema_is_initialized() < 0) {
+                if (ost_job_stats_schema_init() < 0) {
+                        log_fn(LDMSD_LERROR, SAMP" job stats schema create failed\n");
+                        return ENOMEM;
+                }
+        }
+
+        osts_refresh();
+        osts_sample();
+
+        return 0;
+}
+
+static void term(struct ldmsd_plugin *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" term() called\n");
+        osts_destroy();
+        ost_general_schema_fini();
+        ost_job_stats_schema_fini();
+}
+
+static ldms_set_t get_set(struct ldmsd_sampler *self)
+{
+	return NULL;
+}
+
+static const char *usage(struct ldmsd_plugin *self)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" usage() called\n");
+	return  "config name=" SAMP;
+}
+
+static struct ldmsd_sampler ost_job_stats_plugin = {
+	.base = {
+		.name = SAMP,
+		.type = LDMSD_PLUGIN_SAMPLER,
+		.term = term,
+		.config = config,
+		.usage = usage,
+	},
+	.get_set = get_set,
+	.sample = sample,
+};
+
+struct ldmsd_plugin *get_plugin(ldmsd_msg_log_f pf)
+{
+        log_fn = pf;
+        log_fn(LDMSD_LDEBUG, SAMP" get_plugin() called\n");
+        rbt_init(&ost_tree, string_comparator);
+        gethostname(producer_name, sizeof(producer_name));
+
+        return &ost_job_stats_plugin.base;
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost.h
new file mode 100644
index 00000000..0c92d79d
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost.h
@@ -0,0 +1,23 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_OST_H
+#define __LUSTRE_OST_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+#define SAMP "lustre_ost"
+
+extern ldmsd_msg_log_f log_fn;
+
+#ifndef RBT_FOREACH
+#define RBT_FOREACH(rbn, rbt) \
+        for ((rbn) = rbt_min((rbt)); (rbn); (rbn) = rbn_succ((rbn)))
+#endif
+
+#endif /* __LUSTRE_OST_H */
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_general.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_general.c
new file mode 100644
index 00000000..09422071
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_general.c
@@ -0,0 +1,293 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <stdio.h>
+#include <stdint.h>
+#include <dirent.h>
+#include <string.h>
+#include <unistd.h>
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_ost.h"
+#include "lustre_ost_general.h"
+
+static ldms_schema_t ost_general_schema;
+
+static char *obdfilter_stats_uint64_t_entries[] = {
+	"read_bytes.sum", /* sum field from read_bytes entry */
+	"write_bytes.sum",/* sum field from write_bytes entry */
+        "setattr",
+        "punch",
+        "sync",
+        "destroy",
+        "create",
+        "statfs",
+        "get_info",
+        "set_info",
+        "quotactl",
+        "connect",
+        "reconnect",
+        "disconnect",
+        "preprw",
+        "commitrw",
+        "ping",
+        NULL
+};
+
+static char *osd_uint64_t_fields[] = {
+        "filesfree",
+        "filestotal",
+        "kbytesavail",
+        "kbytesfree",
+        "kbytestotal",
+        NULL
+};
+
+int ost_general_schema_is_initialized()
+{
+        if (ost_general_schema != NULL)
+                return 0;
+        else
+                return -1;
+}
+
+int ost_general_schema_init(const char *producer_name)
+{
+        ldms_schema_t sch;
+        int rc;
+        int i;
+
+        log_fn(LDMSD_LDEBUG, SAMP" ost_general_schema_init()\n");
+        sch = ldms_schema_new("llnl_lustre_ost");
+        if (sch == NULL)
+                goto err1;
+        rc = ldms_schema_meta_array_add(sch, "fs_name", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        rc = ldms_schema_meta_array_add(sch, "ost", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        /* add obdfilter stats entries */
+        for (i = 0; obdfilter_stats_uint64_t_entries[i] != NULL; i++) {
+                rc = ldms_schema_metric_add(sch, obdfilter_stats_uint64_t_entries[i],
+                                            LDMS_V_U64);
+                if (rc < 0)
+                        goto err2;
+        }
+        /* add osd entries */
+        for (i = 0; osd_uint64_t_fields[i] != NULL; i++) {
+                rc = ldms_schema_metric_add(sch, osd_uint64_t_fields[i],
+                                            LDMS_V_U64);
+                if (rc < 0)
+                        goto err2;
+        }
+
+        ost_general_schema = sch;
+
+        return 0;
+err2:
+        ldms_schema_delete(sch);
+err1:
+        log_fn(LDMSD_LERROR, SAMP" lustre_ost_general schema creation failed\n");
+        return -1;
+}
+
+void ost_general_schema_fini()
+{
+        log_fn(LDMSD_LDEBUG, SAMP" ost_general_schema_fini()\n");
+        if (ost_general_schema != NULL) {
+                ldms_schema_delete(ost_general_schema);
+                ost_general_schema = NULL;
+        }
+}
+
+/* Returns strdup'ed string or NULL.  Caller must free. */
+char *ost_general_osd_path_find(const char *search_path, const char *ost_name)
+{
+        struct dirent *dirent;
+        DIR *dir;
+        char *osd_path = NULL;
+
+        dir = opendir(search_path);
+        if (dir == NULL) {
+                return NULL;
+        }
+
+        while ((dirent = readdir(dir)) != NULL) {
+                if (dirent->d_type == DT_DIR &&
+                    strncmp(dirent->d_name, "osd-", strlen("osd-")) == 0) {
+                        char tmp_path[PATH_MAX];
+                        snprintf(tmp_path, PATH_MAX, "%s/%s/%s",
+                                 search_path, dirent->d_name, ost_name);
+                        if (access(tmp_path, F_OK) == 0) {
+                                osd_path = strdup(tmp_path);
+                                break;
+                        }
+                }
+        }
+
+        closedir(dir);
+
+        if (osd_path != NULL) {
+                log_fn(LDMSD_LDEBUG, SAMP" for ost %s found osd path %s\n",
+                       ost_name, osd_path);
+        } else {
+                log_fn(LDMSD_LWARNING, SAMP" osd for ost %s not found\n",
+                       ost_name);
+        }
+
+        return osd_path;
+}
+
+static uint64_t file_read_uint64_t(const char *dir, const char *file)
+{
+        uint64_t val;
+        char filepath[PATH_MAX];
+        char valbuf[64];
+        FILE *fp;
+
+        snprintf(filepath, PATH_MAX, "%s/%s", dir, file);
+        fp = fopen(filepath, "r");
+        if (fp == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to open %s\n", filepath);
+                return 0;
+        }
+        if (fgets(valbuf, sizeof(valbuf), fp) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" unable to read %s\n", filepath);
+                fclose(fp);
+                return 0;
+        }
+        fclose(fp);
+
+        /* turn string into int */
+        sscanf(valbuf, "%lu", &val);
+
+        return val;
+}
+
+static void osd_sample(const char *osd_path, ldms_set_t general_metric_set)
+{
+        char *field;
+        uint64_t val;
+        int index;
+        int i;
+
+        for (i = 0; (field = osd_uint64_t_fields[i]) != NULL; i++) {
+                val = file_read_uint64_t(osd_path, field);
+                index = ldms_metric_by_name(general_metric_set, field);
+                ldms_metric_set_u64(general_metric_set, index, val);
+         }
+}
+
+
+void ost_general_destroy(ldms_set_t set)
+{
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_unpublish(set);
+#endif
+        ldms_set_delete(set);
+}
+
+
+/* must be schema created by ost_general_schema_create() */
+ldms_set_t ost_general_create(const char *producer_name, const char *fs_name,
+                              const char *ost_name)
+{
+        ldms_set_t set;
+        int index;
+        char instance_name[256];
+
+        log_fn(LDMSD_LDEBUG, SAMP" ost_general_create()\n");
+        snprintf(instance_name, sizeof(instance_name), "%s/%s",
+                 producer_name, ost_name);
+        set = ldms_set_new(instance_name, ost_general_schema);
+        ldms_set_producer_name_set(set, producer_name);
+        index = ldms_metric_by_name(set, "fs_name");
+        ldms_metric_array_set_str(set, index, fs_name);
+        index = ldms_metric_by_name(set, "ost");
+        ldms_metric_array_set_str(set, index, ost_name);
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_publish(set);
+#endif
+        return set;
+}
+
+static void obdfilter_stats_sample(const char *stats_path,
+                                   ldms_set_t general_metric_set)
+{
+        FILE *sf;
+        char buf[512];
+        char str1[64+1];
+
+        sf = fopen(stats_path, "r");
+        if (sf == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" file %s not found\n",
+                       stats_path);
+                return;
+        }
+
+        /* The first line should always be "snapshot_time"
+           we will ignore it because it always contains the time that we read
+           from the file, not any information about when the stats last
+           changed */
+        if (fgets(buf, sizeof(buf), sf) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" failed on read from %s\n",
+                       stats_path);
+                goto out1;
+        }
+        if (strncmp("snapshot_time", buf, sizeof("snapshot_time")-1) != 0) {
+                log_fn(LDMSD_LWARNING, SAMP" first line in %s is not \"snapshot_time\": %s\n",
+                       stats_path, buf);
+                goto out1;
+        }
+
+        ldms_transaction_begin(general_metric_set);
+        while (fgets(buf, sizeof(buf), sf)) {
+                uint64_t val1, val2;
+                int rc;
+                int index;
+
+                rc = sscanf(buf, "%64s %lu samples [%*[^]]] %*u %*u %lu",
+                            str1, &val1, &val2);
+                if (rc == 2) {
+                        index = ldms_metric_by_name(general_metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" obdfilter stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(general_metric_set, index, val1);
+                        }
+                        continue;
+                } else if (rc == 3) {
+                        int base_name_len = strlen(str1);
+                        sprintf(str1+base_name_len, ".sum"); /* append ".sum" */
+                        index = ldms_metric_by_name(general_metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" obdfilter stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(general_metric_set, index, val2);
+                        }
+                        continue;
+                }
+        }
+        ldms_transaction_end(general_metric_set);
+out1:
+        fclose(sf);
+
+        return;
+}
+
+void ost_general_sample(const char *ost_name, const char *stats_path,
+                        const char *osd_path, ldms_set_t general_metric_set)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" ost_general_sample() %s\n",
+               ost_name);
+        obdfilter_stats_sample(stats_path, general_metric_set);
+        osd_sample(osd_path, general_metric_set);
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_general.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_general.h
new file mode 100644
index 00000000..9b9eec30
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_general.h
@@ -0,0 +1,24 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_OST_GENERAL_H
+#define __LUSTRE_OST_GENERAL_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+int ost_general_schema_is_initialized();
+int ost_general_schema_init();
+void ost_general_schema_fini();
+ldms_set_t ost_general_create(const char *producer_name, const char *fs_name,
+                              const char *ost_name);
+char *ost_general_osd_path_find(const char *search_path, const char *ost_name);
+void ost_general_sample(const char *ost_name, const char *stats_path,
+                        const char *osd_path, ldms_set_t general_metric_set);
+void ost_general_destroy(ldms_set_t set);
+
+#endif /* __LUSTRE_OST_GENERAL_H */
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_job_stats.c b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_job_stats.c
new file mode 100644
index 00000000..17230292
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_job_stats.c
@@ -0,0 +1,320 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+#include "lustre_ost.h"
+#include "lustre_ost_job_stats.h"
+
+/* ldms_schema_t is a pointer */
+static ldms_schema_t ost_job_stats_schema;
+
+struct ost_job_stats_data {
+        char *jobid;
+        uint64_t prev_snapshot_time;
+        ldms_set_t metric_set; /* a pointer */
+        struct rbn job_stats_node;
+};
+
+static char *job_stats_uint64_t_entries[] = {
+        "snapshot_time",
+        "read_bytes_sum",
+        "write_bytes_sum",
+        "getattr",
+        "setattr",
+        "punch",
+        "sync",
+        "destroy",
+        "create",
+        "statfs",
+        "get_info",
+        "set_info",
+        "quotactl",
+        NULL
+};
+
+static int string_comparator(void *a, const void *b)
+{
+        return strcmp((char *)a, (char *)b);
+}
+
+int ost_job_stats_schema_is_initialized()
+{
+        if (ost_job_stats_schema != NULL)
+                return 0;
+        else
+                return -1;
+}
+
+
+int ost_job_stats_schema_init(const char *producer_name)
+{
+        /* ldms_schema_t is a pointer */
+        ldms_schema_t sch;
+        int i;
+        int rc;
+
+        sch = ldms_schema_new("llnl_lustre_ost_job_stats");
+        if (sch == NULL)
+                goto err1;
+        rc = ldms_schema_meta_array_add(sch, "fs_name", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        rc = ldms_schema_meta_array_add(sch, "ost", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        rc = ldms_schema_meta_array_add(sch, "job_id", LDMS_V_CHAR_ARRAY, 64);
+        if (rc < 0)
+                goto err2;
+        for (i = 0; job_stats_uint64_t_entries[i] != NULL; i++) {
+                rc = ldms_schema_metric_add(sch, job_stats_uint64_t_entries[i],
+                                            LDMS_V_U64);
+                if (rc < 0)
+                        goto err2;
+        }
+
+        ost_job_stats_schema = sch;
+
+        return 0;
+err2:
+        ldms_schema_delete(sch);
+err1:
+        log_fn(LDMSD_LERROR, SAMP" lustre_ost_job_stats schema creation failed\n");
+        return -1;
+}
+
+void ost_job_stats_schema_fini()
+{
+        log_fn(LDMSD_LDEBUG, SAMP" ost_job_stats_schema_fini()\n");
+        if (ost_job_stats_schema != NULL) {
+                ldms_schema_delete(ost_job_stats_schema);
+                ost_job_stats_schema = NULL;
+        }
+}
+
+static struct ost_job_stats_data *ost_job_stats_data_create(const char *producer_name,
+                                                            const char *jobid,
+                                                            const char *fs_name,
+                                                            const char *ost_name)
+{
+        struct ost_job_stats_data *job_stats;
+        int index;
+        char instance_name[256];
+
+        log_fn(LDMSD_LDEBUG, SAMP" ost_job_stats_data_create() jobid=%s\n",
+               jobid);
+        job_stats = calloc(1, sizeof(*job_stats));
+        if (job_stats == NULL)
+                goto out1;
+        job_stats->jobid = strdup(jobid);
+        if (job_stats->jobid == NULL)
+                goto out2;
+        job_stats->metric_set = ldms_set_new(instance_name,
+                                             ost_job_stats_schema);
+        snprintf(instance_name, sizeof(instance_name), "%s/%s/%s",
+                 producer_name, ost_name, jobid);
+        if (job_stats->metric_set == NULL)
+                goto out3;
+        rbn_init(&job_stats->job_stats_node, job_stats->jobid);
+
+        ldms_set_producer_name_set(job_stats->metric_set, producer_name);
+        index = ldms_metric_by_name(job_stats->metric_set, "fs_name");
+        ldms_metric_array_set_str(job_stats->metric_set, index, fs_name);
+        index = ldms_metric_by_name(job_stats->metric_set, "ost");
+        ldms_metric_array_set_str(job_stats->metric_set, index, ost_name);
+        index = ldms_metric_by_name(job_stats->metric_set, "job_id");
+        ldms_metric_array_set_str(job_stats->metric_set, index, jobid);
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_publish(job_stats->metric_set);
+#endif
+        return job_stats;
+out3:
+        free(job_stats->jobid);
+out2:
+        free(job_stats);
+out1:
+        log_fn(LDMSD_LERROR, SAMP" ost_job_stats_data_create failed\n");
+        return NULL;
+}
+
+static void ost_job_stats_data_destroy(struct ost_job_stats_data *job_stats)
+{
+        log_fn(LDMSD_LDEBUG, SAMP" ost_job_stats_data_destroy() jobid=%s\n",
+               job_stats->jobid);
+#if HAVE_DECL_LDMS_SET_PUBLISH
+        ldms_set_unpublish(job_stats->metric_set);
+#endif
+        ldms_set_delete(job_stats->metric_set);
+        free(job_stats->jobid);
+        free(job_stats);
+}
+
+void ost_job_stats_destroy(struct rbt *job_stats_tree)
+{
+        struct rbn *rbn;
+        struct ost_job_stats_data *job_stats;
+
+        while (!rbt_empty(job_stats_tree)) {
+                rbn = rbt_min(job_stats_tree);
+                job_stats = container_of(rbn, struct ost_job_stats_data,
+                                         job_stats_node);
+                rbt_del(job_stats_tree, rbn);
+                ost_job_stats_data_destroy(job_stats);
+        }
+}
+
+static void job_stats_sample_stop(struct ost_job_stats_data **job_stats)
+{
+        if (*job_stats != NULL) {
+                if (!ldms_set_is_consistent((*job_stats)->metric_set)) {
+                        ldms_transaction_end((*job_stats)->metric_set);
+                }
+                *job_stats = NULL;
+        }
+}
+
+/* Read job_stats file, and for each seen jobid:
+
+   1) If we have not seen the jobid before, create the associated
+      metric set.
+   2) Update the metrics in the metric set.
+
+   We also need to track which jobids are not seen so that we may
+   destroy that metric set which is no longer needed.  We assume
+   that we can remove the metric set immediately because lustre
+   leaves the jobid around for a while.  The amount of time is
+   configurable in job_cleanup_interval, and defaults to 600 seconds.
+   As long as the job_cleanup_interval in Lustre is sufficently longer
+   than the ldms aggregator polling interval, there is no need for
+   additional caching in ldms.
+*/
+void ost_job_stats_sample(const char *producer_name, const char *fs_name,
+                          const char *ost_name, const char *job_stats_path,
+                          struct rbt *job_stats_tree)
+{
+        FILE *js; /* job_stats */
+        char buf[512];
+        struct rbt new_job_stats;
+        struct ost_job_stats_data *job_stats = NULL;
+
+        log_fn(LDMSD_LDEBUG, SAMP" ost_job_stats_sample() %s\n",
+               ost_name);
+        js = fopen(job_stats_path, "r");
+        if (js == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" file %s not found\n",
+                       job_stats_path);
+                return;
+        }
+
+        /* The first line should always be "job_stats:" */
+        if (fgets(buf, sizeof(buf), js) == NULL) {
+                log_fn(LDMSD_LWARNING, SAMP" failed on read from %s\n",
+                       job_stats_path);
+                goto out1;
+        }
+        if (strncmp("job_stats:", buf, sizeof("job_stats:")-1) != 0) {
+                log_fn(LDMSD_LWARNING, SAMP" first line in %s is not \"job_stats:\": %s\n",
+                       job_stats_path, buf);
+                goto out1;
+        }
+
+        rbt_init(&new_job_stats, string_comparator);
+        /* start new empty rbt for job stats we see this time */
+        while (fgets(buf, sizeof(buf), js)) {
+                char str1[64+1];
+                uint64_t val1;
+                int rc;
+                int index;
+
+                rc = sscanf(buf, " - job_id: %s", str1);
+                if (rc == 1) {
+                        struct rbn *rbn;
+
+                        job_stats_sample_stop(&job_stats);
+                        rbn = rbt_find(job_stats_tree, str1);
+                        if (rbn) {
+                                job_stats = container_of(rbn, struct ost_job_stats_data, job_stats_node);
+                                rbt_del(job_stats_tree, &job_stats->job_stats_node);
+                        } else {
+                                job_stats = ost_job_stats_data_create(producer_name, str1, fs_name, ost_name);
+                        }
+                        if (job_stats != NULL) {
+                                rbt_ins(&new_job_stats, &job_stats->job_stats_node);
+                        }
+                        continue;
+                }
+                if (job_stats == NULL) {
+                        /* We must have failed to find or allocate the job_stats
+                           structure, so we have no where to put metrics.  We'll
+                           just skip everything until we see the next job_id
+                           section in the file. */
+                        continue;
+                }
+                rc = sscanf(buf, " snapshot_time: %lu", &val1);
+                if (rc == 1) {
+                        /* only update the metric if a change of snapshot time
+                           tells us that the data has changed */
+                        if (job_stats->prev_snapshot_time == val1)
+                                continue;
+                        log_fn(LDMSD_LDEBUG, SAMP" jobid %s has updated data\n",
+                               job_stats->jobid);
+                        job_stats->prev_snapshot_time = val1;
+                        ldms_transaction_begin(job_stats->metric_set);
+                        index = ldms_metric_by_name(job_stats->metric_set, "snapshot_time");
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" ost job_stats metric not found: snapshot_time\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(job_stats->metric_set, index, val1);
+                        }
+                        continue;
+                }
+                if (ldms_set_is_consistent(job_stats->metric_set)) {
+                        /* We recognized the jobid, but the data hasn't changed,
+                           so just ignore the data lines */
+                        continue;
+                }
+                rc = sscanf(buf, " %64[^:]: { samples: %*u, unit: bytes, min: %*u, max: %*u, sum: %lu }",
+                            str1, &val1);
+                if (rc == 2) {
+                        int base_name_len = strlen(str1);
+                        sprintf(str1+base_name_len, "_sum");
+                        index = ldms_metric_by_name(job_stats->metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" ost job_stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(job_stats->metric_set, index, val1);
+                        }
+                        continue;
+                }
+                rc = sscanf(buf, " %64[^:]: { samples: %lu",
+                            str1, &val1);
+                if (rc == 2) {
+                        index = ldms_metric_by_name(job_stats->metric_set, str1);
+                        if (index == -1) {
+                                log_fn(LDMSD_LWARNING, SAMP" ost job_stats metric not found: %s\n",
+                                       str1);
+                        } else {
+                                ldms_metric_set_u64(job_stats->metric_set, index, val1);
+                        }
+                        continue;
+                }
+        }
+        job_stats_sample_stop(&job_stats);
+
+        /* destroy any remaining job_stats since we didn't see them this
+           time (if we had, they would have been moved to new_job_stats) */
+        ost_job_stats_destroy(job_stats_tree);
+
+        /* swap new rbt into old rbt's place */
+        memcpy(job_stats_tree, &new_job_stats, sizeof(struct rbt));
+out1:
+        fclose(js);
+
+        return;
+}
diff --git a/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_job_stats.h b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_job_stats.h
new file mode 100644
index 00000000..35bed104
--- /dev/null
+++ b/ldms/src/contrib/sampler/ldms-plugins-llnl/src/lustre_ost_job_stats.h
@@ -0,0 +1,22 @@
+/* -*- c-basic-offset: 8 -*- */
+/* Copyright 2019 Lawrence Livermore National Security, LLC and other
+ * ldms-plugins-llnl project developers.  See the top-level COPYRIGHT file
+ * for details.
+ *
+ * SPDX-License-Identifier: (GPL-2.0-or-later OR BSD-3-Clause)
+ */
+#ifndef __LUSTRE_OST_JOB_STATS_H
+#define __LUSTRE_OST_JOB_STATS_H
+
+#include <ldms/ldms.h>
+#include <ldms/ldmsd.h>
+
+int ost_job_stats_schema_is_initialized();
+int ost_job_stats_schema_init();
+void ost_job_stats_schema_fini();
+void ost_job_stats_sample(const char *producer_name, const char *fs_name,
+                          const char *ost_name, const char *job_stats_path,
+                          struct rbt *job_stats_tree);
+void ost_job_stats_destroy(struct rbt *job_stats_tree);
+
+#endif /* __LUSTRE_OST_JOB_STATS_H */
diff --git a/m4/contrib_llnl.m4 b/m4/contrib_llnl.m4
new file mode 100644
index 00000000..49eee6f6
--- /dev/null
+++ b/m4/contrib_llnl.m4
@@ -0,0 +1,20 @@
+dnl SYNOPSIS: CONTRIB_LLNL
+dnl add switches for llnl lustre/nvidia plugins
+AC_DEFUN([CONTRIB_LLNL],[
+AC_ARG_WITH([dcgm],
+  [AS_HELP_STRING([--with-dcgm],
+    [Include plugin for Nvidia DCGM @<:@default=check@:>@])],
+  [],
+  [with_dcgm=check])
+LIBDCGM=
+AS_IF([test "x$with_dcgm" != xno],
+      [AC_CHECK_LIB([dcgm], [dcgmInit],
+         [have_dcgm=true],
+         [have_dcgm=false
+          if test "x$with_dcgm" != xcheck; then
+            AC_MSG_FAILURE([--with-dcgm was given, but test for dcgm failed])
+          fi
+         ])],
+      [have_dcgm=false])
+AM_CONDITIONAL([HAVE_DCGM], [test x$have_dcgm = xtrue])
+])
